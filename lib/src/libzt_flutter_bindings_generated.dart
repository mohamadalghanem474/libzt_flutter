// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for `src/libzt_flutter.h`.
///
/// Regenerate bindings with `dart run ffigen --config ffigen.yaml`.
///
class LibztFlutterBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  LibztFlutterBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  LibztFlutterBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Error variable set after each `zts_*` socket call. Provides additional error context.
  late final ffi.Pointer<ffi.Int> _zts_errno = _lookup<ffi.Int>('zts_errno');

  int get zts_errno => _zts_errno.value;

  set zts_errno(int value) => _zts_errno.value = value;

  int getattrlistbulk(
    int arg0,
    ffi.Pointer<ffi.Void> arg1,
    ffi.Pointer<ffi.Void> arg2,
    int arg3,
    int arg4,
  ) {
    return _getattrlistbulk(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
    );
  }

  late final _getattrlistbulkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size, ffi.Uint64)>>('getattrlistbulk');
  late final _getattrlistbulk = _getattrlistbulkPtr.asFunction<
      int Function(
          int, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  int getattrlistat(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<ffi.Void> arg2,
    ffi.Pointer<ffi.Void> arg3,
    int arg4,
    int arg5,
  ) {
    return _getattrlistat(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
      arg5,
    );
  }

  late final _getattrlistatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.UnsignedLong)>>('getattrlistat');
  late final _getattrlistat = _getattrlistatPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>, int, int)>();

  int setattrlistat(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<ffi.Void> arg2,
    ffi.Pointer<ffi.Void> arg3,
    int arg4,
    int arg5,
  ) {
    return _setattrlistat(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
      arg5,
    );
  }

  late final _setattrlistatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Uint32)>>('setattrlistat');
  late final _setattrlistat = _setattrlistatPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>, int, int)>();

  int freadlink(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _freadlink(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _freadlinkPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Size)>>('freadlink');
  late final _freadlink =
      _freadlinkPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  int faccessat(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
    int arg3,
  ) {
    return _faccessat(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _faccessatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int, ffi.Int)>>('faccessat');
  late final _faccessat = _faccessatPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int, int)>();

  int fchownat(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
    int arg3,
    int arg4,
  ) {
    return _fchownat(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
    );
  }

  late final _fchownatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>, uid_t, gid_t,
              ffi.Int)>>('fchownat');
  late final _fchownat = _fchownatPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int, int, int)>();

  int linkat(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
    ffi.Pointer<ffi.Char> arg3,
    int arg4,
  ) {
    return _linkat(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
    );
  }

  late final _linkatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Pointer<ffi.Char>, ffi.Int)>>('linkat');
  late final _linkat = _linkatPtr.asFunction<
      int Function(
          int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, int)>();

  int readlinkat(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<ffi.Char> arg2,
    int arg3,
  ) {
    return _readlinkat(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _readlinkatPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(ffi.Int, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('readlinkat');
  late final _readlinkat = _readlinkatPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int symlinkat(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
    ffi.Pointer<ffi.Char> arg2,
  ) {
    return _symlinkat(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _symlinkatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Pointer<ffi.Char>)>>('symlinkat');
  late final _symlinkat = _symlinkatPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int unlinkat(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _unlinkat(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _unlinkatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>>('unlinkat');
  late final _unlinkat =
      _unlinkatPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  /// POSIX.1-1990
  void _exit(
    int arg0,
  ) {
    return __exit(
      arg0,
    );
  }

  late final __exitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('_exit');
  late final __exit = __exitPtr.asFunction<void Function(int)>();

  int access(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _access(
      arg0,
      arg1,
    );
  }

  late final _accessPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int)>>(
      'access');
  late final _access =
      _accessPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int alarm(
    int arg0,
  ) {
    return _alarm(
      arg0,
    );
  }

  late final _alarmPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.UnsignedInt)>>(
          'alarm');
  late final _alarm = _alarmPtr.asFunction<int Function(int)>();

  int chdir(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _chdir(
      arg0,
    );
  }

  late final _chdirPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'chdir');
  late final _chdir =
      _chdirPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int chown(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
    int arg2,
  ) {
    return _chown(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _chownPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, uid_t, gid_t)>>('chown');
  late final _chown =
      _chownPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int, int)>();

  int close(
    int arg0,
  ) {
    return _close(
      arg0,
    );
  }

  late final _closePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('close');
  late final _close = _closePtr.asFunction<int Function(int)>();

  int dup(
    int arg0,
  ) {
    return _dup(
      arg0,
    );
  }

  late final _dupPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('dup');
  late final _dup = _dupPtr.asFunction<int Function(int)>();

  int dup2(
    int arg0,
    int arg1,
  ) {
    return _dup2(
      arg0,
      arg1,
    );
  }

  late final _dup2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>('dup2');
  late final _dup2 = _dup2Ptr.asFunction<int Function(int, int)>();

  int execl(
    ffi.Pointer<ffi.Char> __path,
    ffi.Pointer<ffi.Char> __arg0,
  ) {
    return _execl(
      __path,
      __arg0,
    );
  }

  late final _execlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('execl');
  late final _execl = _execlPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int execle(
    ffi.Pointer<ffi.Char> __path,
    ffi.Pointer<ffi.Char> __arg0,
  ) {
    return _execle(
      __path,
      __arg0,
    );
  }

  late final _execlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('execle');
  late final _execle = _execlePtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int execlp(
    ffi.Pointer<ffi.Char> __file,
    ffi.Pointer<ffi.Char> __arg0,
  ) {
    return _execlp(
      __file,
      __arg0,
    );
  }

  late final _execlpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('execlp');
  late final _execlp = _execlpPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int execv(
    ffi.Pointer<ffi.Char> __path,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __argv,
  ) {
    return _execv(
      __path,
      __argv,
    );
  }

  late final _execvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('execv');
  late final _execv = _execvPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int execve(
    ffi.Pointer<ffi.Char> __file,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __argv,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __envp,
  ) {
    return _execve(
      __file,
      __argv,
      __envp,
    );
  }

  late final _execvePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('execve');
  late final _execve = _execvePtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int execvp(
    ffi.Pointer<ffi.Char> __file,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __argv,
  ) {
    return _execvp(
      __file,
      __argv,
    );
  }

  late final _execvpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('execvp');
  late final _execvp = _execvpPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int fork() {
    return _fork();
  }

  late final _forkPtr = _lookup<ffi.NativeFunction<pid_t Function()>>('fork');
  late final _fork = _forkPtr.asFunction<int Function()>();

  int fpathconf(
    int arg0,
    int arg1,
  ) {
    return _fpathconf(
      arg0,
      arg1,
    );
  }

  late final _fpathconfPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Int, ffi.Int)>>(
          'fpathconf');
  late final _fpathconf = _fpathconfPtr.asFunction<int Function(int, int)>();

  ffi.Pointer<ffi.Char> getcwd(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _getcwd(
      arg0,
      arg1,
    );
  }

  late final _getcwdPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Size)>>('getcwd');
  late final _getcwd = _getcwdPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  int getegid() {
    return _getegid();
  }

  late final _getegidPtr =
      _lookup<ffi.NativeFunction<gid_t Function()>>('getegid');
  late final _getegid = _getegidPtr.asFunction<int Function()>();

  int geteuid() {
    return _geteuid();
  }

  late final _geteuidPtr =
      _lookup<ffi.NativeFunction<uid_t Function()>>('geteuid');
  late final _geteuid = _geteuidPtr.asFunction<int Function()>();

  int getgid() {
    return _getgid();
  }

  late final _getgidPtr =
      _lookup<ffi.NativeFunction<gid_t Function()>>('getgid');
  late final _getgid = _getgidPtr.asFunction<int Function()>();

  int getgroups(
    int arg0,
    ffi.Pointer<gid_t> arg1,
  ) {
    return _getgroups(
      arg0,
      arg1,
    );
  }

  late final _getgroupsPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<gid_t>)>>(
      'getgroups');
  late final _getgroups =
      _getgroupsPtr.asFunction<int Function(int, ffi.Pointer<gid_t>)>();

  ffi.Pointer<ffi.Char> getlogin() {
    return _getlogin();
  }

  late final _getloginPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>('getlogin');
  late final _getlogin =
      _getloginPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  int getpgrp() {
    return _getpgrp();
  }

  late final _getpgrpPtr =
      _lookup<ffi.NativeFunction<pid_t Function()>>('getpgrp');
  late final _getpgrp = _getpgrpPtr.asFunction<int Function()>();

  int getpid() {
    return _getpid();
  }

  late final _getpidPtr =
      _lookup<ffi.NativeFunction<pid_t Function()>>('getpid');
  late final _getpid = _getpidPtr.asFunction<int Function()>();

  int getppid() {
    return _getppid();
  }

  late final _getppidPtr =
      _lookup<ffi.NativeFunction<pid_t Function()>>('getppid');
  late final _getppid = _getppidPtr.asFunction<int Function()>();

  int getuid() {
    return _getuid();
  }

  late final _getuidPtr =
      _lookup<ffi.NativeFunction<uid_t Function()>>('getuid');
  late final _getuid = _getuidPtr.asFunction<int Function()>();

  int isatty(
    int arg0,
  ) {
    return _isatty(
      arg0,
    );
  }

  late final _isattyPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('isatty');
  late final _isatty = _isattyPtr.asFunction<int Function(int)>();

  int link(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _link(
      arg0,
      arg1,
    );
  }

  late final _linkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('link');
  late final _link = _linkPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int lseek(
    int arg0,
    int arg1,
    int arg2,
  ) {
    return _lseek(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _lseekPtr =
      _lookup<ffi.NativeFunction<off_t Function(ffi.Int, off_t, ffi.Int)>>(
          'lseek');
  late final _lseek = _lseekPtr.asFunction<int Function(int, int, int)>();

  int pathconf(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _pathconf(
      arg0,
      arg1,
    );
  }

  late final _pathconfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>, ffi.Int)>>('pathconf');
  late final _pathconf =
      _pathconfPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int pause() {
    return _pause();
  }

  late final _pausePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('pause');
  late final _pause = _pausePtr.asFunction<int Function()>();

  int pipe(
    ffi.Pointer<ffi.Int> arg0,
  ) {
    return _pipe(
      arg0,
    );
  }

  late final _pipePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Int>)>>(
          'pipe');
  late final _pipe = _pipePtr.asFunction<int Function(ffi.Pointer<ffi.Int>)>();

  int read(
    int arg0,
    ffi.Pointer<ffi.Void> arg1,
    int arg2,
  ) {
    return _read(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _readPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size)>>('read');
  late final _read =
      _readPtr.asFunction<int Function(int, ffi.Pointer<ffi.Void>, int)>();

  int rmdir(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _rmdir(
      arg0,
    );
  }

  late final _rmdirPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'rmdir');
  late final _rmdir =
      _rmdirPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int setgid(
    int arg0,
  ) {
    return _setgid(
      arg0,
    );
  }

  late final _setgidPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(gid_t)>>('setgid');
  late final _setgid = _setgidPtr.asFunction<int Function(int)>();

  int setpgid(
    int arg0,
    int arg1,
  ) {
    return _setpgid(
      arg0,
      arg1,
    );
  }

  late final _setpgidPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(pid_t, pid_t)>>('setpgid');
  late final _setpgid = _setpgidPtr.asFunction<int Function(int, int)>();

  int setsid() {
    return _setsid();
  }

  late final _setsidPtr =
      _lookup<ffi.NativeFunction<pid_t Function()>>('setsid');
  late final _setsid = _setsidPtr.asFunction<int Function()>();

  int setuid(
    int arg0,
  ) {
    return _setuid(
      arg0,
    );
  }

  late final _setuidPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(uid_t)>>('setuid');
  late final _setuid = _setuidPtr.asFunction<int Function(int)>();

  int sleep(
    int arg0,
  ) {
    return _sleep(
      arg0,
    );
  }

  late final _sleepPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.UnsignedInt)>>(
          'sleep');
  late final _sleep = _sleepPtr.asFunction<int Function(int)>();

  int sysconf(
    int arg0,
  ) {
    return _sysconf(
      arg0,
    );
  }

  late final _sysconfPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Int)>>('sysconf');
  late final _sysconf = _sysconfPtr.asFunction<int Function(int)>();

  int tcgetpgrp(
    int arg0,
  ) {
    return _tcgetpgrp(
      arg0,
    );
  }

  late final _tcgetpgrpPtr =
      _lookup<ffi.NativeFunction<pid_t Function(ffi.Int)>>('tcgetpgrp');
  late final _tcgetpgrp = _tcgetpgrpPtr.asFunction<int Function(int)>();

  int tcsetpgrp(
    int arg0,
    int arg1,
  ) {
    return _tcsetpgrp(
      arg0,
      arg1,
    );
  }

  late final _tcsetpgrpPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, pid_t)>>(
          'tcsetpgrp');
  late final _tcsetpgrp = _tcsetpgrpPtr.asFunction<int Function(int, int)>();

  ffi.Pointer<ffi.Char> ttyname(
    int arg0,
  ) {
    return _ttyname(
      arg0,
    );
  }

  late final _ttynamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'ttyname');
  late final _ttyname =
      _ttynamePtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  int ttyname_r(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _ttyname_r(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _ttyname_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Size)>>('ttyname_r');
  late final _ttyname_r =
      _ttyname_rPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  int unlink(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _unlink(
      arg0,
    );
  }

  late final _unlinkPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'unlink');
  late final _unlink =
      _unlinkPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int write(
    int __fd,
    ffi.Pointer<ffi.Void> __buf,
    int __nbyte,
  ) {
    return _write(
      __fd,
      __buf,
      __nbyte,
    );
  }

  late final _writePtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size)>>('write');
  late final _write =
      _writePtr.asFunction<int Function(int, ffi.Pointer<ffi.Void>, int)>();

  int confstr(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _confstr(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _confstrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Size)>>('confstr');
  late final _confstr =
      _confstrPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  int getopt(
    int arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
    ffi.Pointer<ffi.Char> arg2,
  ) {
    return _getopt(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _getoptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('getopt');
  late final _getopt = _getoptPtr.asFunction<
      int Function(
          int, ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  /// getopt(3) external variables
  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _optarg =
      _lookup<ffi.Pointer<ffi.Char>>('optarg');

  ffi.Pointer<ffi.Char> get optarg => _optarg.value;

  set optarg(ffi.Pointer<ffi.Char> value) => _optarg.value = value;

  late final ffi.Pointer<ffi.Int> _optind = _lookup<ffi.Int>('optind');

  int get optind => _optind.value;

  set optind(int value) => _optind.value = value;

  late final ffi.Pointer<ffi.Int> _opterr = _lookup<ffi.Int>('opterr');

  int get opterr => _opterr.value;

  set opterr(int value) => _opterr.value = value;

  late final ffi.Pointer<ffi.Int> _optopt = _lookup<ffi.Int>('optopt');

  int get optopt => _optopt.value;

  set optopt(int value) => _optopt.value = value;

  ffi.Pointer<ffi.Char> ctermid(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _ctermid(
      arg0,
    );
  }

  late final _ctermidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('ctermid');
  late final _ctermid = _ctermidPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Void> brk(
    ffi.Pointer<ffi.Void> arg0,
  ) {
    return _brk(
      arg0,
    );
  }

  late final _brkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('brk');
  late final _brk = _brkPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  int chroot(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _chroot(
      arg0,
    );
  }

  late final _chrootPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'chroot');
  late final _chroot =
      _chrootPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> crypt(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _crypt(
      arg0,
      arg1,
    );
  }

  late final _cryptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('crypt');
  late final _crypt = _cryptPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  void encrypt(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _encrypt(
      arg0,
      arg1,
    );
  }

  late final _encryptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Char>, ffi.Int)>>('encrypt');
  late final _encrypt =
      _encryptPtr.asFunction<void Function(ffi.Pointer<ffi.Char>, int)>();

  int fchdir(
    int arg0,
  ) {
    return _fchdir(
      arg0,
    );
  }

  late final _fchdirPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('fchdir');
  late final _fchdir = _fchdirPtr.asFunction<int Function(int)>();

  int gethostid() {
    return _gethostid();
  }

  late final _gethostidPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('gethostid');
  late final _gethostid = _gethostidPtr.asFunction<int Function()>();

  int getpgid(
    int arg0,
  ) {
    return _getpgid(
      arg0,
    );
  }

  late final _getpgidPtr =
      _lookup<ffi.NativeFunction<pid_t Function(pid_t)>>('getpgid');
  late final _getpgid = _getpgidPtr.asFunction<int Function(int)>();

  int getsid(
    int arg0,
  ) {
    return _getsid(
      arg0,
    );
  }

  late final _getsidPtr =
      _lookup<ffi.NativeFunction<pid_t Function(pid_t)>>('getsid');
  late final _getsid = _getsidPtr.asFunction<int Function(int)>();

  int getdtablesize() {
    return _getdtablesize();
  }

  late final _getdtablesizePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('getdtablesize');
  late final _getdtablesize = _getdtablesizePtr.asFunction<int Function()>();

  int getpagesize() {
    return _getpagesize();
  }

  late final _getpagesizePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('getpagesize');
  late final _getpagesize = _getpagesizePtr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> getpass(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _getpass(
      arg0,
    );
  }

  late final _getpassPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('getpass');
  late final _getpass = _getpassPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> getwd(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _getwd(
      arg0,
    );
  }

  late final _getwdPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('getwd');
  late final _getwd = _getwdPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int lchown(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
    int arg2,
  ) {
    return _lchown(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _lchownPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, uid_t, gid_t)>>('lchown');
  late final _lchown =
      _lchownPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int, int)>();

  int lockf(
    int arg0,
    int arg1,
    int arg2,
  ) {
    return _lockf(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _lockfPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, off_t)>>(
          'lockf');
  late final _lockf = _lockfPtr.asFunction<int Function(int, int, int)>();

  int nice(
    int arg0,
  ) {
    return _nice(
      arg0,
    );
  }

  late final _nicePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('nice');
  late final _nice = _nicePtr.asFunction<int Function(int)>();

  int pread(
    int __fd,
    ffi.Pointer<ffi.Void> __buf,
    int __nbyte,
    int __offset,
  ) {
    return _pread(
      __fd,
      __buf,
      __nbyte,
      __offset,
    );
  }

  late final _preadPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(
              ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size, off_t)>>('pread');
  late final _pread = _preadPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Void>, int, int)>();

  int pwrite(
    int __fd,
    ffi.Pointer<ffi.Void> __buf,
    int __nbyte,
    int __offset,
  ) {
    return _pwrite(
      __fd,
      __buf,
      __nbyte,
      __offset,
    );
  }

  late final _pwritePtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(
              ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size, off_t)>>('pwrite');
  late final _pwrite = _pwritePtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> sbrk(
    int arg0,
  ) {
    return _sbrk(
      arg0,
    );
  }

  late final _sbrkPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Int)>>(
          'sbrk');
  late final _sbrk = _sbrkPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  int setpgrp() {
    return _setpgrp();
  }

  late final _setpgrpPtr =
      _lookup<ffi.NativeFunction<pid_t Function()>>('setpgrp');
  late final _setpgrp = _setpgrpPtr.asFunction<int Function()>();

  int setregid(
    int arg0,
    int arg1,
  ) {
    return _setregid(
      arg0,
      arg1,
    );
  }

  late final _setregidPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(gid_t, gid_t)>>('setregid');
  late final _setregid = _setregidPtr.asFunction<int Function(int, int)>();

  int setreuid(
    int arg0,
    int arg1,
  ) {
    return _setreuid(
      arg0,
      arg1,
    );
  }

  late final _setreuidPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(uid_t, uid_t)>>('setreuid');
  late final _setreuid = _setreuidPtr.asFunction<int Function(int, int)>();

  void swab(
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<ffi.Void> arg1,
    int arg2,
  ) {
    return _swab(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _swabPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ssize_t)>>('swab');
  late final _swab = _swabPtr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  void sync1() {
    return _sync1();
  }

  late final _sync1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('sync');
  late final _sync1 = _sync1Ptr.asFunction<void Function()>();

  int truncate(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _truncate(
      arg0,
      arg1,
    );
  }

  late final _truncatePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, off_t)>>(
      'truncate');
  late final _truncate =
      _truncatePtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int ualarm(
    int arg0,
    int arg1,
  ) {
    return _ualarm(
      arg0,
      arg1,
    );
  }

  late final _ualarmPtr =
      _lookup<ffi.NativeFunction<useconds_t Function(useconds_t, useconds_t)>>(
          'ualarm');
  late final _ualarm = _ualarmPtr.asFunction<int Function(int, int)>();

  int usleep(
    int arg0,
  ) {
    return _usleep(
      arg0,
    );
  }

  late final _usleepPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(useconds_t)>>('usleep');
  late final _usleep = _usleepPtr.asFunction<int Function(int)>();

  int vfork() {
    return _vfork();
  }

  late final _vforkPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('vfork');
  late final _vfork = _vforkPtr.asFunction<int Function()>();

  /// End XSI
  int fsync(
    int arg0,
  ) {
    return _fsync(
      arg0,
    );
  }

  late final _fsyncPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('fsync');
  late final _fsync = _fsyncPtr.asFunction<int Function(int)>();

  int ftruncate(
    int arg0,
    int arg1,
  ) {
    return _ftruncate(
      arg0,
      arg1,
    );
  }

  late final _ftruncatePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, off_t)>>(
          'ftruncate');
  late final _ftruncate = _ftruncatePtr.asFunction<int Function(int, int)>();

  int getlogin_r(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _getlogin_r(
      arg0,
      arg1,
    );
  }

  late final _getlogin_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('getlogin_r');
  late final _getlogin_r =
      _getlogin_rPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int fchown(
    int arg0,
    int arg1,
    int arg2,
  ) {
    return _fchown(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _fchownPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, uid_t, gid_t)>>(
          'fchown');
  late final _fchown = _fchownPtr.asFunction<int Function(int, int, int)>();

  int gethostname(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _gethostname(
      arg0,
      arg1,
    );
  }

  late final _gethostnamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('gethostname');
  late final _gethostname =
      _gethostnamePtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int readlink(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _readlink(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _readlinkPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('readlink');
  late final _readlink = _readlinkPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int setegid(
    int arg0,
  ) {
    return _setegid(
      arg0,
    );
  }

  late final _setegidPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(gid_t)>>('setegid');
  late final _setegid = _setegidPtr.asFunction<int Function(int)>();

  int seteuid(
    int arg0,
  ) {
    return _seteuid(
      arg0,
    );
  }

  late final _seteuidPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(uid_t)>>('seteuid');
  late final _seteuid = _seteuidPtr.asFunction<int Function(int)>();

  int symlink(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _symlink(
      arg0,
      arg1,
    );
  }

  late final _symlinkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('symlink');
  late final _symlink = _symlinkPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int __darwin_check_fd_set_overflow(
    int arg0,
    ffi.Pointer<ffi.Void> arg1,
    int arg2,
  ) {
    return ___darwin_check_fd_set_overflow(
      arg0,
      arg1,
      arg2,
    );
  }

  late final ___darwin_check_fd_set_overflowPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Void>,
              ffi.Int)>>('__darwin_check_fd_set_overflow');
  late final ___darwin_check_fd_set_overflow =
      ___darwin_check_fd_set_overflowPtr
          .asFunction<int Function(int, ffi.Pointer<ffi.Void>, int)>();

  int pselect(
    int arg0,
    ffi.Pointer<fd_set> arg1,
    ffi.Pointer<fd_set> arg2,
    ffi.Pointer<fd_set> arg3,
    ffi.Pointer<timespec> arg4,
    ffi.Pointer<sigset_t> arg5,
  ) {
    return _pselect(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
      arg5,
    );
  }

  late final _pselectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int,
              ffi.Pointer<fd_set>,
              ffi.Pointer<fd_set>,
              ffi.Pointer<fd_set>,
              ffi.Pointer<timespec>,
              ffi.Pointer<sigset_t>)>>('pselect');
  late final _pselect = _pselectPtr.asFunction<
      int Function(int, ffi.Pointer<fd_set>, ffi.Pointer<fd_set>,
          ffi.Pointer<fd_set>, ffi.Pointer<timespec>, ffi.Pointer<sigset_t>)>();

  int select(
    int arg0,
    ffi.Pointer<fd_set> arg1,
    ffi.Pointer<fd_set> arg2,
    ffi.Pointer<fd_set> arg3,
    ffi.Pointer<timeval> arg4,
  ) {
    return _select(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
    );
  }

  late final _selectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<fd_set>, ffi.Pointer<fd_set>,
              ffi.Pointer<fd_set>, ffi.Pointer<timeval>)>>('select');
  late final _select = _selectPtr.asFunction<
      int Function(int, ffi.Pointer<fd_set>, ffi.Pointer<fd_set>,
          ffi.Pointer<fd_set>, ffi.Pointer<timeval>)>();

  void _Exit(
    int arg0,
  ) {
    return __Exit(
      arg0,
    );
  }

  late final __ExitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('_Exit');
  late final __Exit = __ExitPtr.asFunction<void Function(int)>();

  int accessx_np(
    ffi.Pointer<accessx_descriptor> arg0,
    int arg1,
    ffi.Pointer<ffi.Int> arg2,
    int arg3,
  ) {
    return _accessx_np(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _accessx_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<accessx_descriptor>, ffi.Size,
              ffi.Pointer<ffi.Int>, uid_t)>>('accessx_np');
  late final _accessx_np = _accessx_npPtr.asFunction<
      int Function(
          ffi.Pointer<accessx_descriptor>, int, ffi.Pointer<ffi.Int>, int)>();

  int acct(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _acct(
      arg0,
    );
  }

  late final _acctPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'acct');
  late final _acct = _acctPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int add_profil(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
    int arg2,
    int arg3,
  ) {
    return _add_profil(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _add_profilPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size, ffi.UnsignedLong,
              ffi.UnsignedInt)>>('add_profil');
  late final _add_profil = _add_profilPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, int, int, int)>();

  void endusershell() {
    return _endusershell();
  }

  late final _endusershellPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('endusershell');
  late final _endusershell = _endusershellPtr.asFunction<void Function()>();

  int execvP(
    ffi.Pointer<ffi.Char> __file,
    ffi.Pointer<ffi.Char> __searchpath,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __argv,
  ) {
    return _execvP(
      __file,
      __searchpath,
      __argv,
    );
  }

  late final _execvPPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('execvP');
  late final _execvP = _execvPPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  ffi.Pointer<ffi.Char> fflagstostr(
    int arg0,
  ) {
    return _fflagstostr(
      arg0,
    );
  }

  late final _fflagstostrPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.UnsignedLong)>>(
      'fflagstostr');
  late final _fflagstostr =
      _fflagstostrPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  int getdomainname(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _getdomainname(
      arg0,
      arg1,
    );
  }

  late final _getdomainnamePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int)>>(
      'getdomainname');
  late final _getdomainname =
      _getdomainnamePtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int getgrouplist(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
    ffi.Pointer<ffi.Int> arg2,
    ffi.Pointer<ffi.Int> arg3,
  ) {
    return _getgrouplist(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _getgrouplistPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('getgrouplist');
  late final _getgrouplist = _getgrouplistPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>)>();

  int gethostuuid(
    ffi.Pointer<ffi.UnsignedChar> arg0,
    ffi.Pointer<timespec> arg1,
  ) {
    return _gethostuuid(
      arg0,
      arg1,
    );
  }

  late final _gethostuuidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<timespec>)>>('gethostuuid');
  late final _gethostuuid = _gethostuuidPtr.asFunction<
      int Function(ffi.Pointer<ffi.UnsignedChar>, ffi.Pointer<timespec>)>();

  int getmode(
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) {
    return _getmode(
      arg0,
      arg1,
    );
  }

  late final _getmodePtr = _lookup<
          ffi.NativeFunction<mode_t Function(ffi.Pointer<ffi.Void>, mode_t)>>(
      'getmode');
  late final _getmode =
      _getmodePtr.asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  int getpeereid(
    int arg0,
    ffi.Pointer<uid_t> arg1,
    ffi.Pointer<gid_t> arg2,
  ) {
    return _getpeereid(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _getpeereidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<uid_t>, ffi.Pointer<gid_t>)>>('getpeereid');
  late final _getpeereid = _getpeereidPtr
      .asFunction<int Function(int, ffi.Pointer<uid_t>, ffi.Pointer<gid_t>)>();

  int getsgroups_np(
    ffi.Pointer<ffi.Int> arg0,
    ffi.Pointer<ffi.UnsignedChar> arg1,
  ) {
    return _getsgroups_np(
      arg0,
      arg1,
    );
  }

  late final _getsgroups_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.UnsignedChar>)>>('getsgroups_np');
  late final _getsgroups_np = _getsgroups_npPtr.asFunction<
      int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.UnsignedChar>)>();

  ffi.Pointer<ffi.Char> getusershell() {
    return _getusershell();
  }

  late final _getusershellPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'getusershell');
  late final _getusershell =
      _getusershellPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  int getwgroups_np(
    ffi.Pointer<ffi.Int> arg0,
    ffi.Pointer<ffi.UnsignedChar> arg1,
  ) {
    return _getwgroups_np(
      arg0,
      arg1,
    );
  }

  late final _getwgroups_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.UnsignedChar>)>>('getwgroups_np');
  late final _getwgroups_np = _getwgroups_npPtr.asFunction<
      int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.UnsignedChar>)>();

  int initgroups(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _initgroups(
      arg0,
      arg1,
    );
  }

  late final _initgroupsPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int)>>(
      'initgroups');
  late final _initgroups =
      _initgroupsPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int issetugid() {
    return _issetugid();
  }

  late final _issetugidPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('issetugid');
  late final _issetugid = _issetugidPtr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> mkdtemp(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _mkdtemp(
      arg0,
    );
  }

  late final _mkdtempPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('mkdtemp');
  late final _mkdtemp = _mkdtempPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int mknod(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
    int arg2,
  ) {
    return _mknod(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _mknodPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, mode_t, dev_t)>>('mknod');
  late final _mknod =
      _mknodPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int, int)>();

  int mkpath_np(
    ffi.Pointer<ffi.Char> path,
    int omode,
  ) {
    return _mkpath_np(
      path,
      omode,
    );
  }

  late final _mkpath_npPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, mode_t)>>(
      'mkpath_np');
  late final _mkpath_np =
      _mkpath_npPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int mkpathat_np(
    int dfd,
    ffi.Pointer<ffi.Char> path,
    int omode,
  ) {
    return _mkpathat_np(
      dfd,
      path,
      omode,
    );
  }

  late final _mkpathat_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, mode_t)>>('mkpathat_np');
  late final _mkpathat_np = _mkpathat_npPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  int mkstemp(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _mkstemp(
      arg0,
    );
  }

  late final _mkstempPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'mkstemp');
  late final _mkstemp =
      _mkstempPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int mkstemps(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _mkstemps(
      arg0,
      arg1,
    );
  }

  late final _mkstempsPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int)>>(
      'mkstemps');
  late final _mkstemps =
      _mkstempsPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> mktemp(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _mktemp(
      arg0,
    );
  }

  late final _mktempPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('mktemp');
  late final _mktemp = _mktempPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int mkostemp(
    ffi.Pointer<ffi.Char> path,
    int oflags,
  ) {
    return _mkostemp(
      path,
      oflags,
    );
  }

  late final _mkostempPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int)>>(
      'mkostemp');
  late final _mkostemp =
      _mkostempPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int mkostemps(
    ffi.Pointer<ffi.Char> path,
    int slen,
    int oflags,
  ) {
    return _mkostemps(
      path,
      slen,
      oflags,
    );
  }

  late final _mkostempsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Int, ffi.Int)>>('mkostemps');
  late final _mkostemps =
      _mkostempsPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int, int)>();

  /// Non-portable mkstemp that uses open_dprotected_np
  int mkstemp_dprotected_np(
    ffi.Pointer<ffi.Char> path,
    int dpclass,
    int dpflags,
  ) {
    return _mkstemp_dprotected_np(
      path,
      dpclass,
      dpflags,
    );
  }

  late final _mkstemp_dprotected_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Int)>>('mkstemp_dprotected_np');
  late final _mkstemp_dprotected_np = _mkstemp_dprotected_npPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, int, int)>();

  ffi.Pointer<ffi.Char> mkdtempat_np(
    int dfd,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _mkdtempat_np(
      dfd,
      path,
    );
  }

  late final _mkdtempat_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int, ffi.Pointer<ffi.Char>)>>('mkdtempat_np');
  late final _mkdtempat_np = _mkdtempat_npPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>)>();

  int mkstempsat_np(
    int dfd,
    ffi.Pointer<ffi.Char> path,
    int slen,
  ) {
    return _mkstempsat_np(
      dfd,
      path,
      slen,
    );
  }

  late final _mkstempsat_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>>('mkstempsat_np');
  late final _mkstempsat_np = _mkstempsat_npPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  int mkostempsat_np(
    int dfd,
    ffi.Pointer<ffi.Char> path,
    int slen,
    int oflags,
  ) {
    return _mkostempsat_np(
      dfd,
      path,
      slen,
      oflags,
    );
  }

  late final _mkostempsat_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Int)>>('mkostempsat_np');
  late final _mkostempsat_np = _mkostempsat_npPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int, int)>();

  int nfssvc(
    int arg0,
    ffi.Pointer<ffi.Void> arg1,
  ) {
    return _nfssvc(
      arg0,
      arg1,
    );
  }

  late final _nfssvcPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Void>)>>(
      'nfssvc');
  late final _nfssvc =
      _nfssvcPtr.asFunction<int Function(int, ffi.Pointer<ffi.Void>)>();

  int profil(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
    int arg2,
    int arg3,
  ) {
    return _profil(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _profilPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size, ffi.UnsignedLong,
              ffi.UnsignedInt)>>('profil');
  late final _profil = _profilPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, int, int, int)>();

  int pthread_setugid_np(
    int arg0,
    int arg1,
  ) {
    return _pthread_setugid_np(
      arg0,
      arg1,
    );
  }

  late final _pthread_setugid_npPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(uid_t, gid_t)>>(
          'pthread_setugid_np');
  late final _pthread_setugid_np =
      _pthread_setugid_npPtr.asFunction<int Function(int, int)>();

  int pthread_getugid_np(
    ffi.Pointer<uid_t> arg0,
    ffi.Pointer<gid_t> arg1,
  ) {
    return _pthread_getugid_np(
      arg0,
      arg1,
    );
  }

  late final _pthread_getugid_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<uid_t>, ffi.Pointer<gid_t>)>>('pthread_getugid_np');
  late final _pthread_getugid_np = _pthread_getugid_npPtr
      .asFunction<int Function(ffi.Pointer<uid_t>, ffi.Pointer<gid_t>)>();

  int reboot(
    int arg0,
  ) {
    return _reboot(
      arg0,
    );
  }

  late final _rebootPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('reboot');
  late final _reboot = _rebootPtr.asFunction<int Function(int)>();

  int revoke(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _revoke(
      arg0,
    );
  }

  late final _revokePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'revoke');
  late final _revoke =
      _revokePtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int rcmd(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    int arg1,
    ffi.Pointer<ffi.Char> arg2,
    ffi.Pointer<ffi.Char> arg3,
    ffi.Pointer<ffi.Char> arg4,
    ffi.Pointer<ffi.Int> arg5,
  ) {
    return _rcmd(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
      arg5,
    );
  }

  late final _rcmdPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>)>>('rcmd');
  late final _rcmd = _rcmdPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          int,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Int>)>();

  int rcmd_af(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    int arg1,
    ffi.Pointer<ffi.Char> arg2,
    ffi.Pointer<ffi.Char> arg3,
    ffi.Pointer<ffi.Char> arg4,
    ffi.Pointer<ffi.Int> arg5,
    int arg6,
  ) {
    return _rcmd_af(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
      arg5,
      arg6,
    );
  }

  late final _rcmd_afPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>,
              ffi.Int)>>('rcmd_af');
  late final _rcmd_af = _rcmd_afPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          int,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Int>,
          int)>();

  int rresvport(
    ffi.Pointer<ffi.Int> arg0,
  ) {
    return _rresvport(
      arg0,
    );
  }

  late final _rresvportPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Int>)>>(
          'rresvport');
  late final _rresvport =
      _rresvportPtr.asFunction<int Function(ffi.Pointer<ffi.Int>)>();

  int rresvport_af(
    ffi.Pointer<ffi.Int> arg0,
    int arg1,
  ) {
    return _rresvport_af(
      arg0,
      arg1,
    );
  }

  late final _rresvport_afPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Int>, ffi.Int)>>(
      'rresvport_af');
  late final _rresvport_af =
      _rresvport_afPtr.asFunction<int Function(ffi.Pointer<ffi.Int>, int)>();

  int iruserok(
    int arg0,
    int arg1,
    ffi.Pointer<ffi.Char> arg2,
    ffi.Pointer<ffi.Char> arg3,
  ) {
    return _iruserok(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _iruserokPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.UnsignedLong, ffi.Int, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('iruserok');
  late final _iruserok = _iruserokPtr.asFunction<
      int Function(int, int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int iruserok_sa(
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
    int arg2,
    ffi.Pointer<ffi.Char> arg3,
    ffi.Pointer<ffi.Char> arg4,
  ) {
    return _iruserok_sa(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
    );
  }

  late final _iruserok_saPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Int, ffi.Int,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('iruserok_sa');
  late final _iruserok_sa = _iruserok_saPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  int ruserok(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
    ffi.Pointer<ffi.Char> arg2,
    ffi.Pointer<ffi.Char> arg3,
  ) {
    return _ruserok(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _ruserokPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('ruserok');
  late final _ruserok = _ruserokPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  int setdomainname(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _setdomainname(
      arg0,
      arg1,
    );
  }

  late final _setdomainnamePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int)>>(
      'setdomainname');
  late final _setdomainname =
      _setdomainnamePtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int setgroups(
    int arg0,
    ffi.Pointer<gid_t> arg1,
  ) {
    return _setgroups(
      arg0,
      arg1,
    );
  }

  late final _setgroupsPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<gid_t>)>>(
      'setgroups');
  late final _setgroups =
      _setgroupsPtr.asFunction<int Function(int, ffi.Pointer<gid_t>)>();

  void sethostid(
    int arg0,
  ) {
    return _sethostid(
      arg0,
    );
  }

  late final _sethostidPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Long)>>('sethostid');
  late final _sethostid = _sethostidPtr.asFunction<void Function(int)>();

  int sethostname(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _sethostname(
      arg0,
      arg1,
    );
  }

  late final _sethostnamePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int)>>(
      'sethostname');
  late final _sethostname =
      _sethostnamePtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  void setkey(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _setkey(
      arg0,
    );
  }

  late final _setkeyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'setkey');
  late final _setkey =
      _setkeyPtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  int setlogin(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _setlogin(
      arg0,
    );
  }

  late final _setloginPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'setlogin');
  late final _setlogin =
      _setloginPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Void> setmode(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _setmode(
      arg0,
    );
  }

  late final _setmodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Char>)>>('setmode');
  late final _setmode = _setmodePtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Char>)>();

  int setrgid(
    int arg0,
  ) {
    return _setrgid(
      arg0,
    );
  }

  late final _setrgidPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(gid_t)>>('setrgid');
  late final _setrgid = _setrgidPtr.asFunction<int Function(int)>();

  int setruid(
    int arg0,
  ) {
    return _setruid(
      arg0,
    );
  }

  late final _setruidPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(uid_t)>>('setruid');
  late final _setruid = _setruidPtr.asFunction<int Function(int)>();

  int setsgroups_np(
    int arg0,
    ffi.Pointer<ffi.UnsignedChar> arg1,
  ) {
    return _setsgroups_np(
      arg0,
      arg1,
    );
  }

  late final _setsgroups_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.UnsignedChar>)>>('setsgroups_np');
  late final _setsgroups_np = _setsgroups_npPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.UnsignedChar>)>();

  void setusershell() {
    return _setusershell();
  }

  late final _setusershellPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('setusershell');
  late final _setusershell = _setusershellPtr.asFunction<void Function()>();

  int setwgroups_np(
    int arg0,
    ffi.Pointer<ffi.UnsignedChar> arg1,
  ) {
    return _setwgroups_np(
      arg0,
      arg1,
    );
  }

  late final _setwgroups_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.UnsignedChar>)>>('setwgroups_np');
  late final _setwgroups_np = _setwgroups_npPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.UnsignedChar>)>();

  int strtofflags(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.UnsignedLong> arg1,
    ffi.Pointer<ffi.UnsignedLong> arg2,
  ) {
    return _strtofflags(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _strtofflagsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.UnsignedLong>,
              ffi.Pointer<ffi.UnsignedLong>)>>('strtofflags');
  late final _strtofflags = _strtofflagsPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.UnsignedLong>, ffi.Pointer<ffi.UnsignedLong>)>();

  int swapon(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _swapon(
      arg0,
    );
  }

  late final _swaponPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'swapon');
  late final _swapon =
      _swaponPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int ttyslot() {
    return _ttyslot();
  }

  late final _ttyslotPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('ttyslot');
  late final _ttyslot = _ttyslotPtr.asFunction<int Function()>();

  int undelete(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _undelete(
      arg0,
    );
  }

  late final _undeletePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'undelete');
  late final _undelete =
      _undeletePtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int unwhiteout(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _unwhiteout(
      arg0,
    );
  }

  late final _unwhiteoutPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'unwhiteout');
  late final _unwhiteout =
      _unwhiteoutPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Void> valloc(
    int arg0,
  ) {
    return _valloc(
      arg0,
    );
  }

  late final _vallocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'valloc');
  late final _valloc =
      _vallocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  int syscall(
    int arg0,
  ) {
    return _syscall(
      arg0,
    );
  }

  late final _syscallPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('syscall');
  late final _syscall = _syscallPtr.asFunction<int Function(int)>();

  /// getsubopt(3) external variable
  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _suboptarg =
      _lookup<ffi.Pointer<ffi.Char>>('suboptarg');

  ffi.Pointer<ffi.Char> get suboptarg => _suboptarg.value;

  set suboptarg(ffi.Pointer<ffi.Char> value) => _suboptarg.value = value;

  int getsubopt(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg2,
  ) {
    return _getsubopt(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _getsuboptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('getsubopt');
  late final _getsubopt = _getsuboptPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int fgetattrlist(
    int arg0,
    ffi.Pointer<ffi.Void> arg1,
    ffi.Pointer<ffi.Void> arg2,
    int arg3,
    int arg4,
  ) {
    return _fgetattrlist(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
    );
  }

  late final _fgetattrlistPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.UnsignedInt)>>('fgetattrlist');
  late final _fgetattrlist = _fgetattrlistPtr.asFunction<
      int Function(
          int, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  int fsetattrlist(
    int arg0,
    ffi.Pointer<ffi.Void> arg1,
    ffi.Pointer<ffi.Void> arg2,
    int arg3,
    int arg4,
  ) {
    return _fsetattrlist(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
    );
  }

  late final _fsetattrlistPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.UnsignedInt)>>('fsetattrlist');
  late final _fsetattrlist = _fsetattrlistPtr.asFunction<
      int Function(
          int, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  int getattrlist(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Void> arg1,
    ffi.Pointer<ffi.Void> arg2,
    int arg3,
    int arg4,
  ) {
    return _getattrlist(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
    );
  }

  late final _getattrlistPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.UnsignedInt)>>('getattrlist');
  late final _getattrlist = _getattrlistPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>, int, int)>();

  int setattrlist(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Void> arg1,
    ffi.Pointer<ffi.Void> arg2,
    int arg3,
    int arg4,
  ) {
    return _setattrlist(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
    );
  }

  late final _setattrlistPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.UnsignedInt)>>('setattrlist');
  late final _setattrlist = _setattrlistPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>, int, int)>();

  int exchangedata(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _exchangedata(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _exchangedataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('exchangedata');
  late final _exchangedata = _exchangedataPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int getdirentriesattr(
    int arg0,
    ffi.Pointer<ffi.Void> arg1,
    ffi.Pointer<ffi.Void> arg2,
    int arg3,
    ffi.Pointer<ffi.UnsignedInt> arg4,
    ffi.Pointer<ffi.UnsignedInt> arg5,
    ffi.Pointer<ffi.UnsignedInt> arg6,
    int arg7,
  ) {
    return _getdirentriesattr(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
      arg5,
      arg6,
      arg7,
    );
  }

  late final _getdirentriesattrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.UnsignedInt)>>('getdirentriesattr');
  late final _getdirentriesattr = _getdirentriesattrPtr.asFunction<
      int Function(
          int,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          int,
          ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ffi.UnsignedInt>,
          int)>();

  int searchfs(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<fssearchblock> arg1,
    ffi.Pointer<ffi.UnsignedLong> arg2,
    int arg3,
    int arg4,
    ffi.Pointer<searchstate> arg5,
  ) {
    return _searchfs(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
      arg5,
    );
  }

  late final _searchfsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<fssearchblock>,
              ffi.Pointer<ffi.UnsignedLong>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<searchstate>)>>('searchfs');
  late final _searchfs = _searchfsPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<fssearchblock>,
          ffi.Pointer<ffi.UnsignedLong>, int, int, ffi.Pointer<searchstate>)>();

  int fsctl(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
    ffi.Pointer<ffi.Void> arg2,
    int arg3,
  ) {
    return _fsctl(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _fsctlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.UnsignedLong,
              ffi.Pointer<ffi.Void>, ffi.UnsignedInt)>>('fsctl');
  late final _fsctl = _fsctlPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Void>, int)>();

  int ffsctl(
    int arg0,
    int arg1,
    ffi.Pointer<ffi.Void> arg2,
    int arg3,
  ) {
    return _ffsctl(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _ffsctlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.UnsignedLong, ffi.Pointer<ffi.Void>,
              ffi.UnsignedInt)>>('ffsctl');
  late final _ffsctl = _ffsctlPtr
      .asFunction<int Function(int, int, ffi.Pointer<ffi.Void>, int)>();

  int fsync_volume_np(
    int arg0,
    int arg1,
  ) {
    return _fsync_volume_np(
      arg0,
      arg1,
    );
  }

  late final _fsync_volume_npPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'fsync_volume_np');
  late final _fsync_volume_np =
      _fsync_volume_npPtr.asFunction<int Function(int, int)>();

  int sync_volume_np(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _sync_volume_np(
      arg0,
      arg1,
    );
  }

  late final _sync_volume_npPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int)>>(
      'sync_volume_np');
  late final _sync_volume_np =
      _sync_volume_npPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  late final ffi.Pointer<ffi.Int> _optreset = _lookup<ffi.Int>('optreset');

  int get optreset => _optreset.value;

  set optreset(int value) => _optreset.value = value;

  late final ffi.Pointer<zts_in6_addr> _zts_in6addr_any =
      _lookup<zts_in6_addr>('zts_in6addr_any');

  zts_in6_addr get zts_in6addr_any => _zts_in6addr_any.ref;

  /// @brief Generates a node identity (public/secret key-pair) and stores it in a
  /// user-provided buffer.
  ///
  /// @param key User-provided destination buffer
  /// @param key_buf_len Length of user-provided destination buffer. Will be set
  /// to the number of bytes copied.
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_ARG` if invalid argument.
  int zts_id_new(
    ffi.Pointer<ffi.Char> key,
    ffi.Pointer<ffi.UnsignedInt> key_buf_len,
  ) {
    return _zts_id_new(
      key,
      key_buf_len,
    );
  }

  late final _zts_id_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.UnsignedInt>)>>('zts_id_new');
  late final _zts_id_new = _zts_id_newPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.UnsignedInt>)>();

  /// @brief Verifies that a key-pair is valid. Checks formatting and pairing of
  /// key to address.
  ///
  /// @param key Buffer containing key-pair
  /// @param len Length of key-pair buffer
  /// @return `1` if true, `0` if false.
  int zts_id_pair_is_valid(
    ffi.Pointer<ffi.Char> key,
    int len,
  ) {
    return _zts_id_pair_is_valid(
      key,
      len,
    );
  }

  late final _zts_id_pair_is_validPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.UnsignedInt)>>('zts_id_pair_is_valid');
  late final _zts_id_pair_is_valid = _zts_id_pair_is_validPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  /// @brief Instruct ZeroTier to look for node identity files at the given location. This is an
  /// initialization function that can only be called before `zts_node_start()`.
  ///
  /// Note that calling this function is not mandatory and if it is not called the node's keys will be
  /// kept in memory and retrievable via `zts_node_get_id_pair()`.
  ///
  /// See also: `zts_init_from_memory()`
  ///
  /// @param port Path Null-terminated file-system path string
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int zts_init_from_storage(
    ffi.Pointer<ffi.Char> path,
  ) {
    return _zts_init_from_storage(
      path,
    );
  }

  late final _zts_init_from_storagePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'zts_init_from_storage');
  late final _zts_init_from_storage = _zts_init_from_storagePtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// @brief Instruct ZeroTier to use the identity provided in `key`. This is an initialization
  /// function that can only be called before `zts_node_start()`.
  ///
  /// Note that calling this function is not mandatory and if it is not called the node's keys will be
  /// kept in memory and retrievable via `zts_node_get_id_pair()`.
  ///
  /// See also: `zts_init_from_storage()`
  ///
  /// @param key Buffer containing identity key
  /// @param len Length of `key` buffer
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int zts_init_from_memory(
    ffi.Pointer<ffi.Char> key,
    int len,
  ) {
    return _zts_init_from_memory(
      key,
      len,
    );
  }

  late final _zts_init_from_memoryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.UnsignedInt)>>('zts_init_from_memory');
  late final _zts_init_from_memory = _zts_init_from_memoryPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int zts_init_set_event_handler(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
        callback,
  ) {
    return _zts_init_set_event_handler(
      callback,
    );
  }

  late final _zts_init_set_event_handlerPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>>(
      'zts_init_set_event_handler');
  late final _zts_init_set_event_handler =
      _zts_init_set_event_handlerPtr.asFunction<
          int Function(
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>();

  /// @brief Set TCP relay for ZeroTier to use instead of P2P UDP
  ///
  /// @param tcp_relay_addr IP address of TCP relay
  /// @param tcp_relay_port Port of TCP relay
  int zts_init_set_tcp_relay(
    ffi.Pointer<ffi.Char> tcp_relay_addr,
    int tcp_relay_port,
  ) {
    return _zts_init_set_tcp_relay(
      tcp_relay_addr,
      tcp_relay_port,
    );
  }

  late final _zts_init_set_tcp_relayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>,
              ffi.UnsignedShort)>>('zts_init_set_tcp_relay');
  late final _zts_init_set_tcp_relay = _zts_init_set_tcp_relayPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  /// @brief Allow TCP relay for ZeroTier to use instead of P2P UDP
  int zts_init_allow_tcp_relay(
    int enabled,
  ) {
    return _zts_init_allow_tcp_relay(
      enabled,
    );
  }

  late final _zts_init_allow_tcp_relayPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'zts_init_allow_tcp_relay');
  late final _zts_init_allow_tcp_relay =
      _zts_init_allow_tcp_relayPtr.asFunction<int Function(int)>();

  /// @brief Force TCP relay for ZeroTier to use instead of P2P UDP
  int zts_init_force_tcp_relay(
    int enabled,
  ) {
    return _zts_init_force_tcp_relay(
      enabled,
    );
  }

  late final _zts_init_force_tcp_relayPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'zts_init_force_tcp_relay');
  late final _zts_init_force_tcp_relay =
      _zts_init_force_tcp_relayPtr.asFunction<int Function(int)>();

  /// @brief Blacklist an interface prefix (or name). This prevents ZeroTier from
  /// sending traffic over matching interfaces. This is an initialization function that can
  /// only be called before `zts_node_start()`.
  ///
  /// @param prefix Null-terminated interface prefix string
  /// @param len Length of prefix string
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int zts_init_blacklist_if(
    ffi.Pointer<ffi.Char> prefix,
    int len,
  ) {
    return _zts_init_blacklist_if(
      prefix,
      len,
    );
  }

  late final _zts_init_blacklist_ifPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('zts_init_blacklist_if');
  late final _zts_init_blacklist_if = _zts_init_blacklist_ifPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  /// @brief Present a root set definition for ZeroTier to use instead of the default.
  /// This is an initialization function that can only be called before `zts_node_start()`.
  ///
  /// @param roots_data Array of roots definition data (binary)
  /// @param len Length of binary data
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int zts_init_set_roots(
    ffi.Pointer<ffi.Void> roots_data,
    int len,
  ) {
    return _zts_init_set_roots(
      roots_data,
      len,
    );
  }

  late final _zts_init_set_rootsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>, ffi.UnsignedInt)>>('zts_init_set_roots');
  late final _zts_init_set_roots = _zts_init_set_rootsPtr
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// @brief Enable or disable low-bandwidth mode. This is an initialization function that can
  /// only be called before `zts_node_start()`.
  ///
  /// Low-bandwidth mode reduces the ambient traffic that ZeroTier sends
  /// at the expense of responsiveness to network changes. It does not reduce your
  /// established connection speeds. It is an adjustment to multiple internal
  /// timers that results in fewer keepalive probes and network configuration
  /// requests being sent. This is a good option if your underlying physical network
  /// doesn't change much.
  ///
  /// @param enabled Whether low-bandwidth mode is enabled or not (default: false)
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem.
  int zts_init_set_low_bandwidth_mode(
    int enabled,
  ) {
    return _zts_init_set_low_bandwidth_mode(
      enabled,
    );
  }

  late final _zts_init_set_low_bandwidth_modePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'zts_init_set_low_bandwidth_mode');
  late final _zts_init_set_low_bandwidth_mode =
      _zts_init_set_low_bandwidth_modePtr.asFunction<int Function(int)>();

  /// @brief Set the port to which the node should bind. This is an initialization function that can
  /// only be called before `zts_node_start()`.
  ///
  /// @param port Port number
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int zts_init_set_port(
    int port,
  ) {
    return _zts_init_set_port(
      port,
    );
  }

  late final _zts_init_set_portPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedShort)>>(
          'zts_init_set_port');
  late final _zts_init_set_port =
      _zts_init_set_portPtr.asFunction<int Function(int)>();

  /// @brief Set range that random ports will be selected from. This is an initialization function that can
  /// only be called before `zts_node_start()`.
  ///
  /// @param start_port Start of port range
  /// @param end_port End of port range
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int zts_init_set_random_port_range(
    int start_port,
    int end_port,
  ) {
    return _zts_init_set_random_port_range(
      start_port,
      end_port,
    );
  }

  late final _zts_init_set_random_port_rangePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.UnsignedShort,
              ffi.UnsignedShort)>>('zts_init_set_random_port_range');
  late final _zts_init_set_random_port_range =
      _zts_init_set_random_port_rangePtr.asFunction<int Function(int, int)>();

  /// @brief Allow or disallow ZeroTier from automatically selecting a backup port to help get through
  /// buggy NAT. This is enabled by default. This port is randomly chosen and should be disabled if you
  /// want to control exactly which ports ZeroTier talks on and (iff) you know with absolute certainty
  /// that traffic on your chosen primary port is allowed. This is an initialization function that can
  /// only be called before `zts_node_start()`.
  ///
  /// @param allowed Whether or not this feature is enabled
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int zts_init_allow_secondary_port(
    int allowed,
  ) {
    return _zts_init_allow_secondary_port(
      allowed,
    );
  }

  late final _zts_init_allow_secondary_portPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt)>>(
          'zts_init_allow_secondary_port');
  late final _zts_init_allow_secondary_port =
      _zts_init_allow_secondary_portPtr.asFunction<int Function(int)>();

  /// @brief Allow or disallow the use of port-mapping. This is enabled by default. This is an
  /// initialization function that can only be called before `zts_node_start()`.
  ///
  /// @param allowed Whether or not this feature is enabled
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int zts_init_allow_port_mapping(
    int allowed,
  ) {
    return _zts_init_allow_port_mapping(
      allowed,
    );
  }

  late final _zts_init_allow_port_mappingPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt)>>(
          'zts_init_allow_port_mapping');
  late final _zts_init_allow_port_mapping =
      _zts_init_allow_port_mappingPtr.asFunction<int Function(int)>();

  /// @brief Enable or disable whether the node will cache network details
  /// (enabled by default when `zts_init_from_storage()` is used.) Must be called before
  /// `zts_node_start()`.
  ///
  /// This can potentially shorten (startup) times between node restarts. This allows the service to
  /// nearly instantly inform the network stack of an address to use for this peer
  /// so that it can create a transport service. This can be disabled for cases where one
  /// may not want network config details to be written to storage. This is
  /// especially useful for situations where address assignments do not change
  /// often.
  ///
  /// See also: `zts_init_allow_peer_cache()`
  ///
  /// @param allowed Whether or not this feature is enabled
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int zts_init_allow_net_cache(
    int allowed,
  ) {
    return _zts_init_allow_net_cache(
      allowed,
    );
  }

  late final _zts_init_allow_net_cachePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt)>>(
          'zts_init_allow_net_cache');
  late final _zts_init_allow_net_cache =
      _zts_init_allow_net_cachePtr.asFunction<int Function(int)>();

  /// @brief Enable or disable whether the node will cache peer details (enabled
  /// by default when `zts_init_from_storage()` is used.) Must be called before `zts_node_start()`.
  ///
  /// This can potentially shorten (connection) times between node restarts. This allows the service to
  /// re-use previously discovered paths to a peer, this prevents the service from
  /// having to go through the entire transport-triggered link provisioning
  /// process. This is especially useful for situations where paths to peers do not
  /// change often. This is enabled by default and can be disabled for cases where
  /// one may not want peer details to be written to storage.
  ///
  /// See also: `zts_init_allow_net_cache()`
  ///
  /// @param allowed Whether or not this feature is enabled
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int zts_init_allow_peer_cache(
    int allowed,
  ) {
    return _zts_init_allow_peer_cache(
      allowed,
    );
  }

  late final _zts_init_allow_peer_cachePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt)>>(
          'zts_init_allow_peer_cache');
  late final _zts_init_allow_peer_cache =
      _zts_init_allow_peer_cachePtr.asFunction<int Function(int)>();

  /// @brief Enable or disable whether the node will cache root definitions (enabled
  /// by default when `zts_init_from_storage()` is used.) Must be called before `zts_node_start()`.
  ///
  /// @param allowed Whether or not this feature is enabled
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int zts_init_allow_roots_cache(
    int allowed,
  ) {
    return _zts_init_allow_roots_cache(
      allowed,
    );
  }

  late final _zts_init_allow_roots_cachePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt)>>(
          'zts_init_allow_roots_cache');
  late final _zts_init_allow_roots_cache =
      _zts_init_allow_roots_cachePtr.asFunction<int Function(int)>();

  /// @brief Enable or disable whether the node will cache identities (enabled
  /// by default when `zts_init_from_storage()` is used.) Must be called before `zts_node_start()`.
  ///
  /// @param allowed Whether or not this feature is enabled
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int zts_init_allow_id_cache(
    int allowed,
  ) {
    return _zts_init_allow_id_cache(
      allowed,
    );
  }

  late final _zts_init_allow_id_cachePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt)>>(
          'zts_init_allow_id_cache');
  late final _zts_init_allow_id_cache =
      _zts_init_allow_id_cachePtr.asFunction<int Function(int)>();

  /// @brief Return whether an address of the given family has been assigned by the network
  ///
  /// @param net_id Network ID
  /// @param family `ZTS_AF_INET`, or `ZTS_AF_INET6`
  /// @return `1` if true, `0` if false.
  int zts_addr_is_assigned(
    int net_id,
    int family,
  ) {
    return _zts_addr_is_assigned(
      net_id,
      family,
    );
  }

  late final _zts_addr_is_assignedPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Uint64, ffi.UnsignedInt)>>(
      'zts_addr_is_assigned');
  late final _zts_addr_is_assigned =
      _zts_addr_is_assignedPtr.asFunction<int Function(int, int)>();

  /// @brief Get the first-assigned IP on the given network.
  ///
  /// To get *all* assigned addresses on a given network, use `zts_addr_get_all()`.
  ///
  /// @param net_id Network ID
  /// @param family `ZTS_AF_INET`, or `ZTS_AF_INET6`
  /// @param addr Destination buffer to hold address
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int zts_addr_get(
    int net_id,
    int family,
    ffi.Pointer<zts_sockaddr_storage> addr,
  ) {
    return _zts_addr_get(
      net_id,
      family,
      addr,
    );
  }

  late final _zts_addr_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Uint64, ffi.UnsignedInt,
              ffi.Pointer<zts_sockaddr_storage>)>>('zts_addr_get');
  late final _zts_addr_get = _zts_addr_getPtr
      .asFunction<int Function(int, int, ffi.Pointer<zts_sockaddr_storage>)>();

  /// @brief Get the first-assigned IP on the given network as a null-terminated human-readable string
  ///
  /// To get *all* assigned addresses on a given network, use `zts_addr_get_all()`.
  ///
  /// @param net_id Network ID
  /// @param family `ZTS_AF_INET`, or `ZTS_AF_INET6`
  /// @param dst Destination buffer
  /// @param len Length of destination buffer (must be exactly `ZTS_IP_MAX_STR_LEN`)
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int zts_addr_get_str(
    int net_id,
    int family,
    ffi.Pointer<ffi.Char> dst,
    int len,
  ) {
    return _zts_addr_get_str(
      net_id,
      family,
      dst,
      len,
    );
  }

  late final _zts_addr_get_strPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Uint64, ffi.UnsignedInt, ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('zts_addr_get_str');
  late final _zts_addr_get_str = _zts_addr_get_strPtr
      .asFunction<int Function(int, int, ffi.Pointer<ffi.Char>, int)>();

  /// @brief Get all IP addresses assigned to this node by the given network
  ///
  /// @param net_id Network ID
  /// @param addr Destination buffer to hold address
  /// @param count Number of addresses returned
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int zts_addr_get_all(
    int net_id,
    ffi.Pointer<zts_sockaddr_storage> addr,
    ffi.Pointer<ffi.UnsignedInt> count,
  ) {
    return _zts_addr_get_all(
      net_id,
      addr,
      count,
    );
  }

  late final _zts_addr_get_allPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Uint64, ffi.Pointer<zts_sockaddr_storage>,
              ffi.Pointer<ffi.UnsignedInt>)>>('zts_addr_get_all');
  late final _zts_addr_get_all = _zts_addr_get_allPtr.asFunction<
      int Function(int, ffi.Pointer<zts_sockaddr_storage>,
          ffi.Pointer<ffi.UnsignedInt>)>();

  /// @brief Compute a `6PLANE` IPv6 address for the given Network ID and Node ID
  ///
  /// @param net_id Network ID
  /// @param node_id Node ID
  /// @param addr Destination structure for address
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_ARG` if invalid argument.
  int zts_addr_compute_6plane(
    int net_id,
    int node_id,
    ffi.Pointer<zts_sockaddr_storage> addr,
  ) {
    return _zts_addr_compute_6plane(
      net_id,
      node_id,
      addr,
    );
  }

  late final _zts_addr_compute_6planePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Uint64, ffi.Uint64,
              ffi.Pointer<zts_sockaddr_storage>)>>('zts_addr_compute_6plane');
  late final _zts_addr_compute_6plane = _zts_addr_compute_6planePtr
      .asFunction<int Function(int, int, ffi.Pointer<zts_sockaddr_storage>)>();

  /// @brief Compute `RFC4193` IPv6 address for the given Network ID and Node ID
  ///
  /// @param net_id Network ID
  /// @param node_id Node ID
  /// @param addr Destination structure for address
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_ARG` if invalid argument.
  int zts_addr_compute_rfc4193(
    int net_id,
    int node_id,
    ffi.Pointer<zts_sockaddr_storage> addr,
  ) {
    return _zts_addr_compute_rfc4193(
      net_id,
      node_id,
      addr,
    );
  }

  late final _zts_addr_compute_rfc4193Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Uint64, ffi.Uint64,
              ffi.Pointer<zts_sockaddr_storage>)>>('zts_addr_compute_rfc4193');
  late final _zts_addr_compute_rfc4193 = _zts_addr_compute_rfc4193Ptr
      .asFunction<int Function(int, int, ffi.Pointer<zts_sockaddr_storage>)>();

  /// @brief Compute `RFC4193` IPv6 address for the given Network ID and Node ID and copy its
  /// null-terminated human-readable string representation into destination buffer.
  ///
  /// @param net_id Network ID
  /// @param node_id Node ID
  /// @param dst Destination string buffer
  /// @param len Length of destination string buffer (must be exactly `ZTS_IP_MAX_STR_LEN`)
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_ARG` if invalid argument.
  int zts_addr_compute_rfc4193_str(
    int net_id,
    int node_id,
    ffi.Pointer<ffi.Char> dst,
    int len,
  ) {
    return _zts_addr_compute_rfc4193_str(
      net_id,
      node_id,
      dst,
      len,
    );
  }

  late final _zts_addr_compute_rfc4193_strPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Uint64, ffi.Uint64, ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('zts_addr_compute_rfc4193_str');
  late final _zts_addr_compute_rfc4193_str = _zts_addr_compute_rfc4193_strPtr
      .asFunction<int Function(int, int, ffi.Pointer<ffi.Char>, int)>();

  /// @brief Compute `6PLANE` IPv6 address for the given Network ID and Node ID and copy its
  /// null-terminated human-readable string representation into destination buffer.
  ///
  /// @param net_id Network ID
  /// @param node_id Node ID
  /// @param dst Destination string buffer
  /// @param len Length of destination string buffer (must be exactly `ZTS_IP_MAX_STR_LEN`)
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_ARG` if invalid argument.
  int zts_addr_compute_6plane_str(
    int net_id,
    int node_id,
    ffi.Pointer<ffi.Char> dst,
    int len,
  ) {
    return _zts_addr_compute_6plane_str(
      net_id,
      node_id,
      dst,
      len,
    );
  }

  late final _zts_addr_compute_6plane_strPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Uint64, ffi.Uint64, ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('zts_addr_compute_6plane_str');
  late final _zts_addr_compute_6plane_str = _zts_addr_compute_6plane_strPtr
      .asFunction<int Function(int, int, ffi.Pointer<ffi.Char>, int)>();

  /// @brief Compute `RFC4193` IPv6 address for the given Network ID and Node ID
  ///
  /// Ad-hoc Network:
  /// ```
  /// ffSSSSEEEE000000
  /// | |   |   |
  /// | |   |   Reserved for future use, must be 0
  /// | |   End of port range (hex)
  /// | Start of port range (hex)
  /// Reserved ZeroTier address prefix indicating a controller-less network.
  /// ```
  /// Ad-hoc networks are public (no access control) networks that have no network
  /// controller. Instead their configuration and other credentials are generated
  /// locally. Ad-hoc networks permit only IPv6 UDP and TCP unicast traffic
  /// (no multicast or broadcast) using 6plane format NDP-emulated IPv6 addresses.
  /// In addition an ad-hoc network ID encodes an IP port range. UDP packets and
  /// TCP SYN (connection open) packets are only allowed to destination ports
  /// within the encoded range.
  ///
  /// For example `ff00160016000000` is an ad-hoc network allowing only SSH,
  /// while `ff0000ffff000000` is an ad-hoc network allowing any UDP or TCP port.
  ///
  /// Keep in mind that these networks are public and anyone in the entire world
  /// can join them. Care must be taken to avoid exposing vulnerable services or
  /// sharing unwanted files or other resources.
  ///
  ///
  /// @param start_port Start of port allowed port range
  /// @param end_port End of allowed port range
  /// @return An Ad-hoc network ID
  int zts_net_compute_adhoc_id(
    int start_port,
    int end_port,
  ) {
    return _zts_net_compute_adhoc_id(
      start_port,
      end_port,
    );
  }

  late final _zts_net_compute_adhoc_idPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Uint16, ffi.Uint16)>>(
          'zts_net_compute_adhoc_id');
  late final _zts_net_compute_adhoc_id =
      _zts_net_compute_adhoc_idPtr.asFunction<int Function(int, int)>();

  /// @brief Join a network
  ///
  /// @param net_id Network ID
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int zts_net_join(
    int net_id,
  ) {
    return _zts_net_join(
      net_id,
    );
  }

  late final _zts_net_joinPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64)>>('zts_net_join');
  late final _zts_net_join = _zts_net_joinPtr.asFunction<int Function(int)>();

  /// @brief Leave a network
  ///
  /// @param net_id Network ID
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int zts_net_leave(
    int net_id,
  ) {
    return _zts_net_leave(
      net_id,
    );
  }

  late final _zts_net_leavePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64)>>(
          'zts_net_leave');
  late final _zts_net_leave = _zts_net_leavePtr.asFunction<int Function(int)>();

  /// @brief Return whether this network is ready to send and receive traffic.
  ///
  /// @return `1` if true, `0` if false.
  int zts_net_transport_is_ready(
    int net_id,
  ) {
    return _zts_net_transport_is_ready(
      net_id,
    );
  }

  late final _zts_net_transport_is_readyPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64)>>(
          'zts_net_transport_is_ready');
  late final _zts_net_transport_is_ready =
      _zts_net_transport_is_readyPtr.asFunction<int Function(int)>();

  /// @brief Get the MAC Address for this node on the given network
  ///
  /// @param net_id Network ID
  ///
  /// @return MAC address in numerical format
  int zts_net_get_mac(
    int net_id,
  ) {
    return _zts_net_get_mac(
      net_id,
    );
  }

  late final _zts_net_get_macPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Uint64)>>(
          'zts_net_get_mac');
  late final _zts_net_get_mac =
      _zts_net_get_macPtr.asFunction<int Function(int)>();

  /// @brief Get the MAC Address for this node on the given network
  ///
  /// @param net_id Network ID
  /// @param dst Destination string buffer
  /// @param len Length of destination string buffer. Must be exactly `ZTS_MAC_ADDRSTRLEN`
  ///
  /// @return MAC address in string format
  int zts_net_get_mac_str(
    int net_id,
    ffi.Pointer<ffi.Char> dst,
    int len,
  ) {
    return _zts_net_get_mac_str(
      net_id,
      dst,
      len,
    );
  }

  late final _zts_net_get_mac_strPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Uint64, ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('zts_net_get_mac_str');
  late final _zts_net_get_mac_str = _zts_net_get_mac_strPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  /// @brief Return whether broadcast is enabled on this network
  ///
  /// @param net_id Network ID
  ///
  /// @return `1` if true, `0` if false.
  int zts_net_get_broadcast(
    int net_id,
  ) {
    return _zts_net_get_broadcast(
      net_id,
    );
  }

  late final _zts_net_get_broadcastPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64)>>(
          'zts_net_get_broadcast');
  late final _zts_net_get_broadcast =
      _zts_net_get_broadcastPtr.asFunction<int Function(int)>();

  /// @brief Get the MTU of the given network
  ///
  /// @param net_id Network ID
  ///
  /// @return MTU
  int zts_net_get_mtu(
    int net_id,
  ) {
    return _zts_net_get_mtu(
      net_id,
    );
  }

  late final _zts_net_get_mtuPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64)>>(
          'zts_net_get_mtu');
  late final _zts_net_get_mtu =
      _zts_net_get_mtuPtr.asFunction<int Function(int)>();

  /// @brief Get the nickname of the network
  ///
  /// @param net_id Network ID
  /// @param dst Destination string buffer
  /// @param len Length of destination string buffer
  ///
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int zts_net_get_name(
    int net_id,
    ffi.Pointer<ffi.Char> dst,
    int len,
  ) {
    return _zts_net_get_name(
      net_id,
      dst,
      len,
    );
  }

  late final _zts_net_get_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Uint64, ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('zts_net_get_name');
  late final _zts_net_get_name = _zts_net_get_namePtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  /// @brief Get the status of the network
  ///
  /// @param net_id Network ID
  ///
  /// @return Status
  int zts_net_get_status(
    int net_id,
  ) {
    return _zts_net_get_status(
      net_id,
    );
  }

  late final _zts_net_get_statusPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64)>>(
          'zts_net_get_status');
  late final _zts_net_get_status =
      _zts_net_get_statusPtr.asFunction<int Function(int)>();

  /// @brief Get the type of network (public or private.)
  ///
  /// @param net_id Network ID
  ///
  /// @return Type
  int zts_net_get_type(
    int net_id,
  ) {
    return _zts_net_get_type(
      net_id,
    );
  }

  late final _zts_net_get_typePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64)>>(
          'zts_net_get_type');
  late final _zts_net_get_type =
      _zts_net_get_typePtr.asFunction<int Function(int)>();

  /// @brief Return whether a managed route of the given address family has been assigned by the
  /// network
  ///
  /// @param net_id Network ID
  /// @param family `ZTS_AF_INET`, or `ZTS_AF_INET6`
  /// @return `1` if true, `0` if false.
  int zts_route_is_assigned(
    int net_id,
    int family,
  ) {
    return _zts_route_is_assigned(
      net_id,
      family,
    );
  }

  late final _zts_route_is_assignedPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Uint64, ffi.UnsignedInt)>>(
      'zts_route_is_assigned');
  late final _zts_route_is_assigned =
      _zts_route_is_assignedPtr.asFunction<int Function(int, int)>();

  /// @brief Start the ZeroTier node. Should be called after calling the relevant
  /// `zts_init_*` functions for your application. To enable storage call
  /// `zts_init_from_storage()` before this function. To enable event callbacks
  /// call `zts_init_set_event_handler()` before this function.
  ///
  /// Note: If neither `zts_init_from_storage()` or `zts_init_from_memory()` are
  /// called a new identity will be generated and will be retrievable via
  /// `zts_node_get_id_pair()` *after* the node has started.
  ///
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem.
  int zts_node_start() {
    return _zts_node_start();
  }

  late final _zts_node_startPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('zts_node_start');
  late final _zts_node_start = _zts_node_startPtr.asFunction<int Function()>();

  /// @brief Return whether the node is online (Can reach the Internet)
  ///
  /// @return `1` if true, `0` if false.
  int zts_node_is_online() {
    return _zts_node_is_online();
  }

  late final _zts_node_is_onlinePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('zts_node_is_online');
  late final _zts_node_is_online =
      _zts_node_is_onlinePtr.asFunction<int Function()>();

  /// @brief Get the public node identity (aka `node_id`). Callable only after the node has been
  /// started.
  ///
  /// @return Identity in numerical form
  int zts_node_get_id() {
    return _zts_node_get_id();
  }

  late final _zts_node_get_idPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function()>>('zts_node_get_id');
  late final _zts_node_get_id =
      _zts_node_get_idPtr.asFunction<int Function()>();

  /// @brief Copy the current node's public (and secret!) identity into a buffer.
  ///
  /// `WARNING`: This function exports your secret key and should be used carefully.
  ///
  /// @param key User-provided destination buffer
  /// @param key_dst_len Length of user-provided destination buffer. Will be set to
  /// number of bytes copied.
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int zts_node_get_id_pair(
    ffi.Pointer<ffi.Char> key,
    ffi.Pointer<ffi.UnsignedInt> key_dst_len,
  ) {
    return _zts_node_get_id_pair(
      key,
      key_dst_len,
    );
  }

  late final _zts_node_get_id_pairPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.UnsignedInt>)>>('zts_node_get_id_pair');
  late final _zts_node_get_id_pair = _zts_node_get_id_pairPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.UnsignedInt>)>();

  /// @brief Get the primary port to which the node is bound. Callable only after the node has been
  /// started.
  ///
  /// @return Port number
  int zts_node_get_port() {
    return _zts_node_get_port();
  }

  late final _zts_node_get_portPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('zts_node_get_port');
  late final _zts_node_get_port =
      _zts_node_get_portPtr.asFunction<int Function()>();

  /// @brief Stop the ZeroTier node and bring down all virtual network
  /// transport services. Callable only after the node has been started.
  ///
  /// While the ZeroTier will stop, the stack driver (with associated
  /// timers) will remain active in case future traffic processing is required.
  /// To stop all activity and free all resources use `zts_free()` instead.
  ///
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem.
  int zts_node_stop() {
    return _zts_node_stop();
  }

  late final _zts_node_stopPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('zts_node_stop');
  late final _zts_node_stop = _zts_node_stopPtr.asFunction<int Function()>();

  /// @brief Stop all background threads, bring down all transport services, free all
  /// resources. After calling this function an application restart will be
  /// required before the library can be used again. Callable only after the node
  /// has been started.
  ///
  /// This should be called at the end of your program or when you do not
  /// anticipate communicating over ZeroTier again.
  ///
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem.
  int zts_node_free() {
    return _zts_node_free();
  }

  late final _zts_node_freePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('zts_node_free');
  late final _zts_node_free = _zts_node_freePtr.asFunction<int Function()>();

  /// @brief Orbit a given moon (user-defined root server)
  ///
  /// @param moon_roots_id World ID
  /// @param moon_seed Seed ID
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int zts_moon_orbit(
    int moon_roots_id,
    int moon_seed,
  ) {
    return _zts_moon_orbit(
      moon_roots_id,
      moon_seed,
    );
  }

  late final _zts_moon_orbitPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64, ffi.Uint64)>>(
          'zts_moon_orbit');
  late final _zts_moon_orbit =
      _zts_moon_orbitPtr.asFunction<int Function(int, int)>();

  /// @brief De-orbit a given moon (user-defined root server)
  ///
  /// @param moon_roots_id World ID
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument.
  int zts_moon_deorbit(
    int moon_roots_id,
  ) {
    return _zts_moon_deorbit(
      moon_roots_id,
    );
  }

  late final _zts_moon_deorbitPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64)>>(
          'zts_moon_deorbit');
  late final _zts_moon_deorbit =
      _zts_moon_deorbitPtr.asFunction<int Function(int)>();

  /// @brief Get all statistical counters for all protocols and levels.
  /// See also: lwip/stats.h.
  ///
  /// This function can only be used in debug builds.
  ///
  /// @param dst Pointer to structure that will be populated with statistics
  ///
  /// @return ZTS_ERR_OK on success. ZTS_ERR_ARG or ZTS_ERR_NO_RESULT on failure.
  int zts_stats_get_all(
    ffi.Pointer<zts_stats_counter_t> dst,
  ) {
    return _zts_stats_get_all(
      dst,
    );
  }

  late final _zts_stats_get_allPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<zts_stats_counter_t>)>>(
      'zts_stats_get_all');
  late final _zts_stats_get_all = _zts_stats_get_allPtr
      .asFunction<int Function(ffi.Pointer<zts_stats_counter_t>)>();

  /// @brief Create a socket
  ///
  /// @param family `ZTS_AF_INET` or `ZTS_AF_INET6`
  /// @param type `ZTS_SOCK_STREAM` or `ZTS_SOCK_DGRAM`
  /// @param protocol Protocols supported on this socket
  /// @return Numbered file descriptor on success, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_bsd_socket(
    int family,
    int type,
    int protocol,
  ) {
    return _zts_bsd_socket(
      family,
      type,
      protocol,
    );
  }

  late final _zts_bsd_socketPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>>(
          'zts_bsd_socket');
  late final _zts_bsd_socket =
      _zts_bsd_socketPtr.asFunction<int Function(int, int, int)>();

  /// @brief Connect a socket to a remote host
  ///
  /// @param fd Socket file descriptor
  /// @param addr Remote host address to connect to
  /// @param addrlen Length of address
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_bsd_connect(
    int fd,
    ffi.Pointer<zts_sockaddr> addr,
    int addrlen,
  ) {
    return _zts_bsd_connect(
      fd,
      addr,
      addrlen,
    );
  }

  late final _zts_bsd_connectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<zts_sockaddr>,
              zts_socklen_t)>>('zts_bsd_connect');
  late final _zts_bsd_connect = _zts_bsd_connectPtr
      .asFunction<int Function(int, ffi.Pointer<zts_sockaddr>, int)>();

  /// @brief Bind a socket to a local address
  ///
  /// @param fd Socket file descriptor
  /// @param addr Local interface address to bind to
  /// @param addrlen Length of address
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_bsd_bind(
    int fd,
    ffi.Pointer<zts_sockaddr> addr,
    int addrlen,
  ) {
    return _zts_bsd_bind(
      fd,
      addr,
      addrlen,
    );
  }

  late final _zts_bsd_bindPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<zts_sockaddr>,
              zts_socklen_t)>>('zts_bsd_bind');
  late final _zts_bsd_bind = _zts_bsd_bindPtr
      .asFunction<int Function(int, ffi.Pointer<zts_sockaddr>, int)>();

  /// @brief Listen for incoming connections on socket
  ///
  /// @param fd Socket file descriptor
  /// @param backlog Number of backlogged connections allowed
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_bsd_listen(
    int fd,
    int backlog,
  ) {
    return _zts_bsd_listen(
      fd,
      backlog,
    );
  }

  late final _zts_bsd_listenPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'zts_bsd_listen');
  late final _zts_bsd_listen =
      _zts_bsd_listenPtr.asFunction<int Function(int, int)>();

  /// @brief Accept an incoming connection
  ///
  /// @param fd Socket file descriptor
  /// @param addr Address of remote host for accepted connection
  /// @param addrlen Length of address
  /// @return New file descriptor if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_bsd_accept(
    int fd,
    ffi.Pointer<zts_sockaddr> addr,
    ffi.Pointer<zts_socklen_t> addrlen,
  ) {
    return _zts_bsd_accept(
      fd,
      addr,
      addrlen,
    );
  }

  late final _zts_bsd_acceptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<zts_sockaddr>,
              ffi.Pointer<zts_socklen_t>)>>('zts_bsd_accept');
  late final _zts_bsd_accept = _zts_bsd_acceptPtr.asFunction<
      int Function(
          int, ffi.Pointer<zts_sockaddr>, ffi.Pointer<zts_socklen_t>)>();

  /// @brief Set socket options.
  ///
  /// @param fd Socket file descriptor
  /// @param level Protocol level to which option name should apply
  /// @param optname Option name to set
  /// @param optval Source of option value to set
  /// @param optlen Length of option value
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_bsd_setsockopt(
    int fd,
    int level,
    int optname,
    ffi.Pointer<ffi.Void> optval,
    int optlen,
  ) {
    return _zts_bsd_setsockopt(
      fd,
      level,
      optname,
      optval,
      optlen,
    );
  }

  late final _zts_bsd_setsockoptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Int, ffi.Int, ffi.Pointer<ffi.Void>,
              zts_socklen_t)>>('zts_bsd_setsockopt');
  late final _zts_bsd_setsockopt = _zts_bsd_setsockoptPtr
      .asFunction<int Function(int, int, int, ffi.Pointer<ffi.Void>, int)>();

  /// @brief Get socket options.
  ///
  /// @param fd Socket file descriptor
  /// @param level Protocol level to which option name should apply
  /// @param optname Option name to get
  /// @param optval Where option value will be stored
  /// @param optlen Length of value
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_bsd_getsockopt(
    int fd,
    int level,
    int optname,
    ffi.Pointer<ffi.Void> optval,
    ffi.Pointer<zts_socklen_t> optlen,
  ) {
    return _zts_bsd_getsockopt(
      fd,
      level,
      optname,
      optval,
      optlen,
    );
  }

  late final _zts_bsd_getsockoptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Int, ffi.Int, ffi.Pointer<ffi.Void>,
              ffi.Pointer<zts_socklen_t>)>>('zts_bsd_getsockopt');
  late final _zts_bsd_getsockopt = _zts_bsd_getsockoptPtr.asFunction<
      int Function(
          int, int, int, ffi.Pointer<ffi.Void>, ffi.Pointer<zts_socklen_t>)>();

  /// @brief Get the name (address) of the local end of the socket
  ///
  /// @param fd Socket file descriptor
  /// @param addr Name associated with this socket
  /// @param addrlen Length of name
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_bsd_getsockname(
    int fd,
    ffi.Pointer<zts_sockaddr> addr,
    ffi.Pointer<zts_socklen_t> addrlen,
  ) {
    return _zts_bsd_getsockname(
      fd,
      addr,
      addrlen,
    );
  }

  late final _zts_bsd_getsocknamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<zts_sockaddr>,
              ffi.Pointer<zts_socklen_t>)>>('zts_bsd_getsockname');
  late final _zts_bsd_getsockname = _zts_bsd_getsocknamePtr.asFunction<
      int Function(
          int, ffi.Pointer<zts_sockaddr>, ffi.Pointer<zts_socklen_t>)>();

  /// @brief Get the name (address) of the remote end of the socket
  ///
  /// @param fd Socket file descriptor
  /// @param addr Name associated with remote end of this socket
  /// @param addrlen Length of name
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_bsd_getpeername(
    int fd,
    ffi.Pointer<zts_sockaddr> addr,
    ffi.Pointer<zts_socklen_t> addrlen,
  ) {
    return _zts_bsd_getpeername(
      fd,
      addr,
      addrlen,
    );
  }

  late final _zts_bsd_getpeernamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<zts_sockaddr>,
              ffi.Pointer<zts_socklen_t>)>>('zts_bsd_getpeername');
  late final _zts_bsd_getpeername = _zts_bsd_getpeernamePtr.asFunction<
      int Function(
          int, ffi.Pointer<zts_sockaddr>, ffi.Pointer<zts_socklen_t>)>();

  /// @brief Close socket.
  ///
  /// @param fd Socket file descriptor
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_bsd_close(
    int fd,
  ) {
    return _zts_bsd_close(
      fd,
    );
  }

  late final _zts_bsd_closePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('zts_bsd_close');
  late final _zts_bsd_close = _zts_bsd_closePtr.asFunction<int Function(int)>();

  /// @brief Monitor multiple file descriptors for "readiness"
  ///
  /// @param nfds Set to the highest numbered file descriptor in any of the given
  /// sets
  /// @param readfds Set of file descriptors to monitor for READ readiness
  /// @param writefds Set of file descriptors to monitor for WRITE readiness
  /// @param exceptfds Set of file descriptors to monitor for exceptional
  /// conditions
  /// @param timeout How long this call should block
  /// @return Number of ready file descriptors on success. `ZTS_ERR_SOCKET`,
  /// `ZTS_ERR_SERVICE` on failure. Sets `zts_errno`
  int zts_bsd_select(
    int nfds,
    ffi.Pointer<zts_fd_set> readfds,
    ffi.Pointer<zts_fd_set> writefds,
    ffi.Pointer<zts_fd_set> exceptfds,
    ffi.Pointer<zts_timeval> timeout,
  ) {
    return _zts_bsd_select(
      nfds,
      readfds,
      writefds,
      exceptfds,
      timeout,
    );
  }

  late final _zts_bsd_selectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int,
              ffi.Pointer<zts_fd_set>,
              ffi.Pointer<zts_fd_set>,
              ffi.Pointer<zts_fd_set>,
              ffi.Pointer<zts_timeval>)>>('zts_bsd_select');
  late final _zts_bsd_select = _zts_bsd_selectPtr.asFunction<
      int Function(int, ffi.Pointer<zts_fd_set>, ffi.Pointer<zts_fd_set>,
          ffi.Pointer<zts_fd_set>, ffi.Pointer<zts_timeval>)>();

  /// @brief Issue file control commands on a socket
  ///
  /// @param fd Socket file descriptor
  /// @param cmd Operation to be performed
  /// @param flags Flags
  /// @return
  int zts_bsd_fcntl(
    int fd,
    int cmd,
    int flags,
  ) {
    return _zts_bsd_fcntl(
      fd,
      cmd,
      flags,
    );
  }

  late final _zts_bsd_fcntlPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>>(
          'zts_bsd_fcntl');
  late final _zts_bsd_fcntl =
      _zts_bsd_fcntlPtr.asFunction<int Function(int, int, int)>();

  /// @brief Wait for some event on a file descriptor.
  ///
  /// @param fds Set of file descriptors to monitor
  /// @param nfds Number of elements in the fds array
  /// @param timeout How long this call should block
  /// @return Number of ready file descriptors if successful, `ZTS_ERR_SERVICE` if
  /// the node experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets
  /// `zts_errno`
  int zts_bsd_poll(
    ffi.Pointer<zts_pollfd> fds,
    int nfds,
    int timeout,
  ) {
    return _zts_bsd_poll(
      fds,
      nfds,
      timeout,
    );
  }

  late final _zts_bsd_pollPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<zts_pollfd>, zts_nfds_t, ffi.Int)>>('zts_bsd_poll');
  late final _zts_bsd_poll = _zts_bsd_pollPtr
      .asFunction<int Function(ffi.Pointer<zts_pollfd>, int, int)>();

  /// @brief Control a device
  ///
  /// @param fd Socket file descriptor
  /// @param request Selects the control function to be performed
  /// @param argp Additional information
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_bsd_ioctl(
    int fd,
    int request,
    ffi.Pointer<ffi.Void> argp,
  ) {
    return _zts_bsd_ioctl(
      fd,
      request,
      argp,
    );
  }

  late final _zts_bsd_ioctlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.UnsignedLong,
              ffi.Pointer<ffi.Void>)>>('zts_bsd_ioctl');
  late final _zts_bsd_ioctl = _zts_bsd_ioctlPtr
      .asFunction<int Function(int, int, ffi.Pointer<ffi.Void>)>();

  /// @brief Send data to remote host
  ///
  /// @param fd Socket file descriptor
  /// @param buf Pointer to data buffer
  /// @param len Length of data to write
  /// @param flags (e.g. `ZTS_MSG_DONTWAIT`, `ZTS_MSG_MORE`)
  /// @return Number of bytes sent if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_bsd_send(
    int fd,
    ffi.Pointer<ffi.Void> buf,
    int len,
    int flags,
  ) {
    return _zts_bsd_send(
      fd,
      buf,
      len,
      flags,
    );
  }

  late final _zts_bsd_sendPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size,
              ffi.Int)>>('zts_bsd_send');
  late final _zts_bsd_send = _zts_bsd_sendPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Void>, int, int)>();

  /// @brief Send data to remote host
  ///
  /// @param fd Socket file descriptor
  /// @param buf Pointer to data buffer
  /// @param len Length of data to write
  /// @param flags Specifies type of message transmission
  /// @param addr Destination address
  /// @param addrlen Length of destination address
  /// @return Number of bytes sent if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_bsd_sendto(
    int fd,
    ffi.Pointer<ffi.Void> buf,
    int len,
    int flags,
    ffi.Pointer<zts_sockaddr> addr,
    int addrlen,
  ) {
    return _zts_bsd_sendto(
      fd,
      buf,
      len,
      flags,
      addr,
      addrlen,
    );
  }

  late final _zts_bsd_sendtoPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size, ffi.Int,
              ffi.Pointer<zts_sockaddr>, zts_socklen_t)>>('zts_bsd_sendto');
  late final _zts_bsd_sendto = _zts_bsd_sendtoPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Void>, int, int,
          ffi.Pointer<zts_sockaddr>, int)>();

  /// @brief Send message to remote host
  ///
  /// @param fd Socket file descriptor
  /// @param msg Message to send
  /// @param flags Specifies type of message transmission
  /// @return Number of bytes sent if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_bsd_sendmsg(
    int fd,
    ffi.Pointer<zts_msghdr> msg,
    int flags,
  ) {
    return _zts_bsd_sendmsg(
      fd,
      msg,
      flags,
    );
  }

  late final _zts_bsd_sendmsgPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(
              ffi.Int, ffi.Pointer<zts_msghdr>, ffi.Int)>>('zts_bsd_sendmsg');
  late final _zts_bsd_sendmsg = _zts_bsd_sendmsgPtr
      .asFunction<int Function(int, ffi.Pointer<zts_msghdr>, int)>();

  /// @brief Receive data from remote host
  ///
  /// @param fd Socket file descriptor
  /// @param buf Pointer to data buffer
  /// @param len Length of data buffer
  /// @param flags Specifies the type of message receipt
  /// @return Number of bytes received if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_bsd_recv(
    int fd,
    ffi.Pointer<ffi.Void> buf,
    int len,
    int flags,
  ) {
    return _zts_bsd_recv(
      fd,
      buf,
      len,
      flags,
    );
  }

  late final _zts_bsd_recvPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size,
              ffi.Int)>>('zts_bsd_recv');
  late final _zts_bsd_recv = _zts_bsd_recvPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Void>, int, int)>();

  /// @brief Receive data from remote host
  ///
  /// @param fd Socket file descriptor
  /// @param buf Pointer to data buffer
  /// @param len Length of data buffer
  /// @param flags Specifies the type of message receipt
  /// @param addr Destination address buffer
  /// @param addrlen Length of destination address buffer
  /// @return Number of bytes received if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_bsd_recvfrom(
    int fd,
    ffi.Pointer<ffi.Void> buf,
    int len,
    int flags,
    ffi.Pointer<zts_sockaddr> addr,
    ffi.Pointer<zts_socklen_t> addrlen,
  ) {
    return _zts_bsd_recvfrom(
      fd,
      buf,
      len,
      flags,
      addr,
      addrlen,
    );
  }

  late final _zts_bsd_recvfromPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(
              ffi.Int,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Int,
              ffi.Pointer<zts_sockaddr>,
              ffi.Pointer<zts_socklen_t>)>>('zts_bsd_recvfrom');
  late final _zts_bsd_recvfrom = _zts_bsd_recvfromPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Void>, int, int,
          ffi.Pointer<zts_sockaddr>, ffi.Pointer<zts_socklen_t>)>();

  /// @brief Receive a message from remote host
  ///
  /// @param fd Socket file descriptor
  /// @param msg Message that was received
  /// @param flags Specifies the type of message receipt
  /// @return Number of bytes received if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_bsd_recvmsg(
    int fd,
    ffi.Pointer<zts_msghdr> msg,
    int flags,
  ) {
    return _zts_bsd_recvmsg(
      fd,
      msg,
      flags,
    );
  }

  late final _zts_bsd_recvmsgPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(
              ffi.Int, ffi.Pointer<zts_msghdr>, ffi.Int)>>('zts_bsd_recvmsg');
  late final _zts_bsd_recvmsg = _zts_bsd_recvmsgPtr
      .asFunction<int Function(int, ffi.Pointer<zts_msghdr>, int)>();

  /// @brief Read data from socket onto buffer
  ///
  /// @param fd Socket file descriptor
  /// @param buf Pointer to data buffer
  /// @param len Length of data buffer to receive data
  /// @return Number of bytes read if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_bsd_read(
    int fd,
    ffi.Pointer<ffi.Void> buf,
    int len,
  ) {
    return _zts_bsd_read(
      fd,
      buf,
      len,
    );
  }

  late final _zts_bsd_readPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(
              ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size)>>('zts_bsd_read');
  late final _zts_bsd_read = _zts_bsd_readPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Void>, int)>();

  /// @brief Read data from socket into multiple buffers
  ///
  /// @param fd Socket file descriptor
  /// @param iov Array of destination buffers
  /// @param iovcnt Number of buffers to read into
  /// @return Number of bytes read if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_bsd_readv(
    int fd,
    ffi.Pointer<zts_iovec> iov,
    int iovcnt,
  ) {
    return _zts_bsd_readv(
      fd,
      iov,
      iovcnt,
    );
  }

  late final _zts_bsd_readvPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(
              ffi.Int, ffi.Pointer<zts_iovec>, ffi.Int)>>('zts_bsd_readv');
  late final _zts_bsd_readv = _zts_bsd_readvPtr
      .asFunction<int Function(int, ffi.Pointer<zts_iovec>, int)>();

  /// @brief Write data from buffer to socket
  ///
  /// @param fd Socket file descriptor
  /// @param buf Pointer to data buffer
  /// @param len Length of buffer to write
  /// @return Number of bytes written if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_bsd_write(
    int fd,
    ffi.Pointer<ffi.Void> buf,
    int len,
  ) {
    return _zts_bsd_write(
      fd,
      buf,
      len,
    );
  }

  late final _zts_bsd_writePtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(
              ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size)>>('zts_bsd_write');
  late final _zts_bsd_write = _zts_bsd_writePtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Void>, int)>();

  /// @brief Write data from multiple buffers to socket.
  ///
  /// @param fd Socket file descriptor
  /// @param iov Array of source buffers
  /// @param iovcnt Number of buffers to read from
  /// @return Number of bytes written if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_bsd_writev(
    int fd,
    ffi.Pointer<zts_iovec> iov,
    int iovcnt,
  ) {
    return _zts_bsd_writev(
      fd,
      iov,
      iovcnt,
    );
  }

  late final _zts_bsd_writevPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(
              ffi.Int, ffi.Pointer<zts_iovec>, ffi.Int)>>('zts_bsd_writev');
  late final _zts_bsd_writev = _zts_bsd_writevPtr
      .asFunction<int Function(int, ffi.Pointer<zts_iovec>, int)>();

  /// @brief Shut down some aspect of a socket
  ///
  /// @param fd Socket file descriptor
  /// @param how Which aspects of the socket should be shut down. Options are `ZTS_SHUT_RD`,
  /// `ZTS_SHUT_WR`, or `ZTS_SHUT_RDWR`.
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_bsd_shutdown(
    int fd,
    int how,
  ) {
    return _zts_bsd_shutdown(
      fd,
      how,
    );
  }

  late final _zts_bsd_shutdownPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'zts_bsd_shutdown');
  late final _zts_bsd_shutdown =
      _zts_bsd_shutdownPtr.asFunction<int Function(int, int)>();

  /// @brief Create a socket
  ///
  /// @param family `ZTS_AF_INET` or `ZTS_AF_INET6`
  /// @param type `ZTS_SOCK_STREAM` or `ZTS_SOCK_DGRAM`
  /// @param protocol Protocols supported on this socket
  /// @return Numbered file descriptor on success, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_socket(
    int family,
    int type,
    int protocol,
  ) {
    return _zts_socket(
      family,
      type,
      protocol,
    );
  }

  late final _zts_socketPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>>(
          'zts_socket');
  late final _zts_socket =
      _zts_socketPtr.asFunction<int Function(int, int, int)>();

  /// @brief Connect a socket to a remote host
  ///
  /// This convenience function exists because ZeroTier uses transport-triggered
  /// links. This means that links between peers do not exist until peers try to
  /// talk to each other. This can be a problem during connection procedures since
  /// some of the initial packets are lost. To alleviate the need to try
  /// `zts_bsd_connect` many times, this function will keep re-trying for you, even if
  /// no known routes exist. However, if the socket is set to `non-blocking` mode
  /// it will behave identically to `zts_bsd_connect` and return immediately upon
  /// failure.
  ///
  /// @param fd Socket file descriptor
  /// @param ipstr Human-readable IP string
  /// @param port Port
  /// @param timeout_ms (Approximate) amount of time in milliseconds before
  /// connection attempt is aborted. Will block for `30 seconds` if timeout is
  /// set to `0`.
  ///
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SOCKET` if the function times
  /// out with no connection made, `ZTS_ERR_SERVICE` if the node experiences a
  /// problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_connect(
    int fd,
    ffi.Pointer<ffi.Char> ipstr,
    int port,
    int timeout_ms,
  ) {
    return _zts_connect(
      fd,
      ipstr,
      port,
      timeout_ms,
    );
  }

  late final _zts_connectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>, ffi.UnsignedShort,
              ffi.Int)>>('zts_connect');
  late final _zts_connect = _zts_connectPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int, int)>();

  /// @brief Bind a socket to a local address
  ///
  /// @param fd Socket file descriptor
  /// @param ipstr Human-readable IP string
  /// @param port Port
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_bind(
    int fd,
    ffi.Pointer<ffi.Char> ipstr,
    int port,
  ) {
    return _zts_bind(
      fd,
      ipstr,
      port,
    );
  }

  late final _zts_bindPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.UnsignedShort)>>('zts_bind');
  late final _zts_bind =
      _zts_bindPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  /// @brief Listen for incoming connections on socket
  ///
  /// @param fd Socket file descriptor
  /// @param backlog Number of backlogged connections allowed
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_listen(
    int fd,
    int backlog,
  ) {
    return _zts_listen(
      fd,
      backlog,
    );
  }

  late final _zts_listenPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'zts_listen');
  late final _zts_listen = _zts_listenPtr.asFunction<int Function(int, int)>();

  /// @brief Accept an incoming connection
  ///
  /// @param fd Socket file descriptor
  /// @param remote_addr Buffer that will receive remote host IP string
  /// @param len Size of buffer that will receive remote host IP string
  /// (must be exactly `ZTS_IP_MAX_STR_LEN`)
  /// @param port Port number of the newly connected remote host (value-result)
  /// @return New file descriptor if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_accept(
    int fd,
    ffi.Pointer<ffi.Char> remote_addr,
    int len,
    ffi.Pointer<ffi.UnsignedShort> port,
  ) {
    return _zts_accept(
      fd,
      remote_addr,
      len,
      port,
    );
  }

  late final _zts_acceptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Pointer<ffi.UnsignedShort>)>>('zts_accept');
  late final _zts_accept = _zts_acceptPtr.asFunction<
      int Function(
          int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.UnsignedShort>)>();

  /// @brief Send data to remote host
  ///
  /// @param fd Socket file descriptor
  /// @param buf Pointer to data buffer
  /// @param len Length of data to write
  /// @param flags (e.g. `ZTS_MSG_DONTWAIT`, `ZTS_MSG_MORE`)
  /// @return Number of bytes sent if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_send(
    int fd,
    ffi.Pointer<ffi.Void> buf,
    int len,
    int flags,
  ) {
    return _zts_send(
      fd,
      buf,
      len,
      flags,
    );
  }

  late final _zts_sendPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(
              ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size, ffi.Int)>>('zts_send');
  late final _zts_send = _zts_sendPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Void>, int, int)>();

  /// @brief Receive data from remote host
  ///
  /// @param fd Socket file descriptor
  /// @param buf Pointer to data buffer
  /// @param len Length of data buffer
  /// @param flags Specifies the type of message receipt
  /// @return Number of bytes received if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_recv(
    int fd,
    ffi.Pointer<ffi.Void> buf,
    int len,
    int flags,
  ) {
    return _zts_recv(
      fd,
      buf,
      len,
      flags,
    );
  }

  late final _zts_recvPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(
              ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size, ffi.Int)>>('zts_recv');
  late final _zts_recv = _zts_recvPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Void>, int, int)>();

  /// @brief Read data from socket onto buffer
  ///
  /// @param fd Socket file descriptor
  /// @param buf Pointer to data buffer
  /// @param len Length of data buffer to receive data
  /// @return Number of bytes read if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_read(
    int fd,
    ffi.Pointer<ffi.Void> buf,
    int len,
  ) {
    return _zts_read(
      fd,
      buf,
      len,
    );
  }

  late final _zts_readPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(
              ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size)>>('zts_read');
  late final _zts_read =
      _zts_readPtr.asFunction<int Function(int, ffi.Pointer<ffi.Void>, int)>();

  /// @brief Write data from buffer to socket
  ///
  /// @param fd Socket file descriptor
  /// @param buf Pointer to data buffer
  /// @param len Length of buffer to write
  /// @return Number of bytes written if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_write(
    int fd,
    ffi.Pointer<ffi.Void> buf,
    int len,
  ) {
    return _zts_write(
      fd,
      buf,
      len,
    );
  }

  late final _zts_writePtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(
              ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size)>>('zts_write');
  late final _zts_write =
      _zts_writePtr.asFunction<int Function(int, ffi.Pointer<ffi.Void>, int)>();

  /// @brief Shut down `read` aspect of a socket
  ///
  /// @param fd Socket file descriptor
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_shutdown_rd(
    int fd,
  ) {
    return _zts_shutdown_rd(
      fd,
    );
  }

  late final _zts_shutdown_rdPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('zts_shutdown_rd');
  late final _zts_shutdown_rd =
      _zts_shutdown_rdPtr.asFunction<int Function(int)>();

  /// @brief Shut down `write` aspect of a socket
  ///
  /// @param fd Socket file descriptor
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_shutdown_wr(
    int fd,
  ) {
    return _zts_shutdown_wr(
      fd,
    );
  }

  late final _zts_shutdown_wrPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('zts_shutdown_wr');
  late final _zts_shutdown_wr =
      _zts_shutdown_wrPtr.asFunction<int Function(int)>();

  /// @brief Shut down both `read` and `write` aspect of a socket
  ///
  /// @param fd Socket file descriptor
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_shutdown_rdwr(
    int fd,
  ) {
    return _zts_shutdown_rdwr(
      fd,
    );
  }

  late final _zts_shutdown_rdwrPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'zts_shutdown_rdwr');
  late final _zts_shutdown_rdwr =
      _zts_shutdown_rdwrPtr.asFunction<int Function(int)>();

  /// @brief Close socket.
  ///
  /// @param fd Socket file descriptor
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_close(
    int fd,
  ) {
    return _zts_close(
      fd,
    );
  }

  late final _zts_closePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('zts_close');
  late final _zts_close = _zts_closePtr.asFunction<int Function(int)>();

  /// @brief Get the name (address) of the remote end of the socket
  ///
  /// @param fd Socket file descriptor
  /// @param remote_addr_str Destination buffer to contain name (address) of the remote end of the socket
  /// @param len Length of destination buffer
  /// @param port Value-result parameter that will contain resultant port number
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_getpeername(
    int fd,
    ffi.Pointer<ffi.Char> remote_addr_str,
    int len,
    ffi.Pointer<ffi.UnsignedShort> port,
  ) {
    return _zts_getpeername(
      fd,
      remote_addr_str,
      len,
      port,
    );
  }

  late final _zts_getpeernamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Pointer<ffi.UnsignedShort>)>>('zts_getpeername');
  late final _zts_getpeername = _zts_getpeernamePtr.asFunction<
      int Function(
          int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.UnsignedShort>)>();

  /// @brief Get the name (address) of the local end of the socket
  ///
  /// @param fd Socket file descriptor
  /// @param local_addr_str Destination buffer to contain name (address) of the local end of the socket
  /// @param len Length of destination buffer
  /// @param port Value-result parameter that will contain resultant port number
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_getsockname(
    int fd,
    ffi.Pointer<ffi.Char> local_addr_str,
    int len,
    ffi.Pointer<ffi.UnsignedShort> port,
  ) {
    return _zts_getsockname(
      fd,
      local_addr_str,
      len,
      port,
    );
  }

  late final _zts_getsocknamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Pointer<ffi.UnsignedShort>)>>('zts_getsockname');
  late final _zts_getsockname = _zts_getsocknamePtr.asFunction<
      int Function(
          int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.UnsignedShort>)>();

  /// @brief A convenience function that takes a remote address IP string and creates
  /// the appropriate type of socket, and uses it to connect to a remote host.
  ///
  /// @param remote_ipstr Remote address string. IPv4 or IPv6
  /// @param remote_port Port to
  ///
  /// @return New file descriptor if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_tcp_client(
    ffi.Pointer<ffi.Char> remote_ipstr,
    int remote_port,
  ) {
    return _zts_tcp_client(
      remote_ipstr,
      remote_port,
    );
  }

  late final _zts_tcp_clientPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.UnsignedShort)>>('zts_tcp_client');
  late final _zts_tcp_client =
      _zts_tcp_clientPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  /// @brief A convenience function that takes a remote address IP string and creates
  /// the appropriate type of socket, binds, listens, and then accepts on it.
  ///
  /// @param local_ipstr Local address to bind
  /// @param local_port Local port to bind
  /// @param remote_ipstr String-format IP address of newly connected remote host
  /// @param len Length of `remote_ipstr`
  /// @param remote_port Port of remote host
  ///
  /// @return New file descriptor if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_tcp_server(
    ffi.Pointer<ffi.Char> local_ipstr,
    int local_port,
    ffi.Pointer<ffi.Char> remote_ipstr,
    int len,
    ffi.Pointer<ffi.UnsignedShort> remote_port,
  ) {
    return _zts_tcp_server(
      local_ipstr,
      local_port,
      remote_ipstr,
      len,
      remote_port,
    );
  }

  late final _zts_tcp_serverPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedShort,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.UnsignedShort>)>>('zts_tcp_server');
  late final _zts_tcp_server = _zts_tcp_serverPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, int,
          ffi.Pointer<ffi.UnsignedShort>)>();

  /// @brief A convenience function that takes a remote address IP string and creates
  /// the appropriate type of socket, and binds to it.
  ///
  /// @param local_ipstr Local address to bind
  /// @param local_port Local port to bind
  ///
  /// @return New file descriptor if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_udp_server(
    ffi.Pointer<ffi.Char> local_ipstr,
    int local_port,
  ) {
    return _zts_udp_server(
      local_ipstr,
      local_port,
    );
  }

  late final _zts_udp_serverPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.UnsignedShort)>>('zts_udp_server');
  late final _zts_udp_server =
      _zts_udp_serverPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  /// @brief This function doesn't really do anything other than be a namespace
  /// counterpart to `zts_udp_server`. All this function does is create a
  /// `ZTS_SOCK_DGRAM` socket and return its file descriptor.
  ///
  /// @param remote_ipstr Remote address string. IPv4 or IPv6
  ///
  /// @return New file descriptor if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_udp_client(
    ffi.Pointer<ffi.Char> remote_ipstr,
  ) {
    return _zts_udp_client(
      remote_ipstr,
    );
  }

  late final _zts_udp_clientPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'zts_udp_client');
  late final _zts_udp_client =
      _zts_udp_clientPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// @brief Enable or disable `TCP_NODELAY`. Enabling this is equivalent to
  /// turning off Nagle's algorithm
  ///
  /// @param fd Socket file descriptor
  /// @param enabled `[0, 1]` integer value
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_set_no_delay(
    int fd,
    int enabled,
  ) {
    return _zts_set_no_delay(
      fd,
      enabled,
    );
  }

  late final _zts_set_no_delayPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'zts_set_no_delay');
  late final _zts_set_no_delay =
      _zts_set_no_delayPtr.asFunction<int Function(int, int)>();

  /// @brief Get the last error for the given socket
  ///
  /// @param fd Socket file descriptor
  /// @return Error number defined in `zts_errno_t`. `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_get_last_socket_error(
    int fd,
  ) {
    return _zts_get_last_socket_error(
      fd,
    );
  }

  late final _zts_get_last_socket_errorPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'zts_get_last_socket_error');
  late final _zts_get_last_socket_error =
      _zts_get_last_socket_errorPtr.asFunction<int Function(int)>();

  /// @brief Return amount of data available to read from socket
  ///
  /// @param fd Socket file descriptor
  /// @return Number of bytes available to read. `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_get_data_available(
    int fd,
  ) {
    return _zts_get_data_available(
      fd,
    );
  }

  late final _zts_get_data_availablePtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Int)>>(
          'zts_get_data_available');
  late final _zts_get_data_available =
      _zts_get_data_availablePtr.asFunction<int Function(int)>();

  /// @brief Return whether `TCP_NODELAY` is enabled
  ///
  /// @param fd Socket file descriptor
  /// @return `1` if enabled, `0` if disabled, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_get_no_delay(
    int fd,
  ) {
    return _zts_get_no_delay(
      fd,
    );
  }

  late final _zts_get_no_delayPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'zts_get_no_delay');
  late final _zts_get_no_delay =
      _zts_get_no_delayPtr.asFunction<int Function(int)>();

  /// @brief Enable or disable `SO_LINGER` while also setting its value
  ///
  /// @param fd Socket file descriptor
  /// @param enabled `[0, 1]` integer value
  /// @param value How long socket should linger
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_set_linger(
    int fd,
    int enabled,
    int value,
  ) {
    return _zts_set_linger(
      fd,
      enabled,
      value,
    );
  }

  late final _zts_set_lingerPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>>(
          'zts_set_linger');
  late final _zts_set_linger =
      _zts_set_lingerPtr.asFunction<int Function(int, int, int)>();

  /// @brief Return whether `SO_LINGER` is enabled
  ///
  /// @param fd Socket file descriptor
  /// @return `1` if enabled, `0` if disabled, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_get_linger_enabled(
    int fd,
  ) {
    return _zts_get_linger_enabled(
      fd,
    );
  }

  late final _zts_get_linger_enabledPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'zts_get_linger_enabled');
  late final _zts_get_linger_enabled =
      _zts_get_linger_enabledPtr.asFunction<int Function(int)>();

  /// @brief Return the value of `SO_LINGER`
  ///
  /// @param fd Socket file descriptor
  /// @return Value of `SO_LINGER` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_get_linger_value(
    int fd,
  ) {
    return _zts_get_linger_value(
      fd,
    );
  }

  late final _zts_get_linger_valuePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'zts_get_linger_value');
  late final _zts_get_linger_value =
      _zts_get_linger_valuePtr.asFunction<int Function(int)>();

  /// @brief Return the number of bytes available to read from the network buffer
  ///
  /// @param fd Socket file descriptor
  /// @return Number of bytes to read if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_get_pending_data_size(
    int fd,
  ) {
    return _zts_get_pending_data_size(
      fd,
    );
  }

  late final _zts_get_pending_data_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'zts_get_pending_data_size');
  late final _zts_get_pending_data_size =
      _zts_get_pending_data_sizePtr.asFunction<int Function(int)>();

  /// @brief Enable or disable `SO_REUSEADDR`
  ///
  /// @param fd Socket file descriptor
  /// @param enabled `[0, 1]` integer value
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_set_reuse_addr(
    int fd,
    int enabled,
  ) {
    return _zts_set_reuse_addr(
      fd,
      enabled,
    );
  }

  late final _zts_set_reuse_addrPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'zts_set_reuse_addr');
  late final _zts_set_reuse_addr =
      _zts_set_reuse_addrPtr.asFunction<int Function(int, int)>();

  /// @brief Return whether `SO_REUSEADDR` is enabled
  ///
  /// @param fd Socket file descriptor
  /// @return `1` if enabled, `0` if disabled, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_get_reuse_addr(
    int fd,
  ) {
    return _zts_get_reuse_addr(
      fd,
    );
  }

  late final _zts_get_reuse_addrPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'zts_get_reuse_addr');
  late final _zts_get_reuse_addr =
      _zts_get_reuse_addrPtr.asFunction<int Function(int)>();

  /// @brief Set the value of `SO_RCVTIMEO`
  ///
  /// @param fd Socket file descriptor
  /// @param seconds Number of seconds for timeout
  /// @param microseconds Number of microseconds for timeout
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_set_recv_timeout(
    int fd,
    int seconds,
    int microseconds,
  ) {
    return _zts_set_recv_timeout(
      fd,
      seconds,
      microseconds,
    );
  }

  late final _zts_set_recv_timeoutPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>>(
          'zts_set_recv_timeout');
  late final _zts_set_recv_timeout =
      _zts_set_recv_timeoutPtr.asFunction<int Function(int, int, int)>();

  /// @brief Return the value of `SO_RCVTIMEO`
  ///
  /// @param fd Socket file descriptor
  /// @return Value of `SO_RCVTIMEO` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_get_recv_timeout(
    int fd,
  ) {
    return _zts_get_recv_timeout(
      fd,
    );
  }

  late final _zts_get_recv_timeoutPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'zts_get_recv_timeout');
  late final _zts_get_recv_timeout =
      _zts_get_recv_timeoutPtr.asFunction<int Function(int)>();

  /// @brief Set the value of `SO_SNDTIMEO`
  ///
  /// @param fd Socket file descriptor
  /// @param seconds Number of seconds for timeout
  /// @param microseconds Number of microseconds for timeout
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_set_send_timeout(
    int fd,
    int seconds,
    int microseconds,
  ) {
    return _zts_set_send_timeout(
      fd,
      seconds,
      microseconds,
    );
  }

  late final _zts_set_send_timeoutPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>>(
          'zts_set_send_timeout');
  late final _zts_set_send_timeout =
      _zts_set_send_timeoutPtr.asFunction<int Function(int, int, int)>();

  /// @brief Return the value of `SO_SNDTIMEO`
  ///
  /// @param fd Socket file descriptor
  /// @return Value of `SO_SNDTIMEO` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_get_send_timeout(
    int fd,
  ) {
    return _zts_get_send_timeout(
      fd,
    );
  }

  late final _zts_get_send_timeoutPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'zts_get_send_timeout');
  late final _zts_get_send_timeout =
      _zts_get_send_timeoutPtr.asFunction<int Function(int)>();

  /// @brief Set the value of `SO_SNDBUF`
  ///
  /// @param fd Socket file descriptor
  /// @param size Size of buffer
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_set_send_buf_size(
    int fd,
    int size,
  ) {
    return _zts_set_send_buf_size(
      fd,
      size,
    );
  }

  late final _zts_set_send_buf_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'zts_set_send_buf_size');
  late final _zts_set_send_buf_size =
      _zts_set_send_buf_sizePtr.asFunction<int Function(int, int)>();

  /// @brief Return the value of `SO_SNDBUF`
  ///
  /// @param fd Socket file descriptor
  /// @return Value of `SO_SNDBUF` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_get_send_buf_size(
    int fd,
  ) {
    return _zts_get_send_buf_size(
      fd,
    );
  }

  late final _zts_get_send_buf_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'zts_get_send_buf_size');
  late final _zts_get_send_buf_size =
      _zts_get_send_buf_sizePtr.asFunction<int Function(int)>();

  /// @brief Set the value of `SO_RCVBUF`
  ///
  /// @param fd Socket file descriptor
  /// @param size Size of buffer
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_set_recv_buf_size(
    int fd,
    int size,
  ) {
    return _zts_set_recv_buf_size(
      fd,
      size,
    );
  }

  late final _zts_set_recv_buf_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'zts_set_recv_buf_size');
  late final _zts_set_recv_buf_size =
      _zts_set_recv_buf_sizePtr.asFunction<int Function(int, int)>();

  /// @brief Return the value of `SO_RCVBUF`
  ///
  /// @param fd Socket file descriptor
  /// @return Value of `SO_RCVBUF` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_get_recv_buf_size(
    int fd,
  ) {
    return _zts_get_recv_buf_size(
      fd,
    );
  }

  late final _zts_get_recv_buf_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'zts_get_recv_buf_size');
  late final _zts_get_recv_buf_size =
      _zts_get_recv_buf_sizePtr.asFunction<int Function(int)>();

  /// @brief Set the value of `IP_TTL`
  ///
  /// @param fd Socket file descriptor
  /// @param ttl Value of `IP_TTL`
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_set_ttl(
    int fd,
    int ttl,
  ) {
    return _zts_set_ttl(
      fd,
      ttl,
    );
  }

  late final _zts_set_ttlPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'zts_set_ttl');
  late final _zts_set_ttl =
      _zts_set_ttlPtr.asFunction<int Function(int, int)>();

  /// @brief Return the value of `IP_TTL`
  ///
  /// @param fd Socket file descriptor
  /// @return Value of `IP_TTL` `[0,255]` if successful, `ZTS_ERR_SERVICE` if the
  /// node experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_get_ttl(
    int fd,
  ) {
    return _zts_get_ttl(
      fd,
    );
  }

  late final _zts_get_ttlPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('zts_get_ttl');
  late final _zts_get_ttl = _zts_get_ttlPtr.asFunction<int Function(int)>();

  /// @brief Change blocking behavior `O_NONBLOCK`
  ///
  /// @param fd Socket file descriptor
  /// @param enabled `[0, 1]` integer value, `1` maintains default behavior,
  /// `0` sets to non-blocking mode
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_set_blocking(
    int fd,
    int enabled,
  ) {
    return _zts_set_blocking(
      fd,
      enabled,
    );
  }

  late final _zts_set_blockingPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'zts_set_blocking');
  late final _zts_set_blocking =
      _zts_set_blockingPtr.asFunction<int Function(int, int)>();

  /// @brief Return whether blocking mode `O_NONBLOCK` is enabled
  ///
  /// @param fd Socket file descriptor
  /// @return `1` if enabled, `0` if disabled, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_get_blocking(
    int fd,
  ) {
    return _zts_get_blocking(
      fd,
    );
  }

  late final _zts_get_blockingPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'zts_get_blocking');
  late final _zts_get_blocking =
      _zts_get_blockingPtr.asFunction<int Function(int)>();

  /// @brief Enable or disable `SO_KEEPALIVE`
  ///
  /// @param fd Socket file descriptor
  /// @param enabled `[0, 1]` integer value
  /// @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_set_keepalive(
    int fd,
    int enabled,
  ) {
    return _zts_set_keepalive(
      fd,
      enabled,
    );
  }

  late final _zts_set_keepalivePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'zts_set_keepalive');
  late final _zts_set_keepalive =
      _zts_set_keepalivePtr.asFunction<int Function(int, int)>();

  /// @brief Return whether `SO_KEEPALIVE` is enabled
  ///
  /// @param fd Socket file descriptor
  /// @return `1` if enabled, `0` if disabled, `ZTS_ERR_SERVICE` if the node
  /// experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`
  int zts_get_keepalive(
    int fd,
  ) {
    return _zts_get_keepalive(
      fd,
    );
  }

  late final _zts_get_keepalivePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'zts_get_keepalive');
  late final _zts_get_keepalive =
      _zts_get_keepalivePtr.asFunction<int Function(int)>();

  /// @brief Resolve a host-name
  ///
  /// @param name A null-terminated string representing the name of the host
  /// @return Pointer to struct zts_hostent if successful, NULL otherwise
  ffi.Pointer<zts_hostent> zts_bsd_gethostbyname(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _zts_bsd_gethostbyname(
      name,
    );
  }

  late final _zts_bsd_gethostbynamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<zts_hostent> Function(
              ffi.Pointer<ffi.Char>)>>('zts_bsd_gethostbyname');
  late final _zts_bsd_gethostbyname = _zts_bsd_gethostbynamePtr
      .asFunction<ffi.Pointer<zts_hostent> Function(ffi.Pointer<ffi.Char>)>();

  /// Initialize one of the DNS servers.
  ///
  /// @param index the index of the DNS server to set must be `< DNS_MAX_SERVERS`
  /// @param addr IP address of the DNS server to set
  int zts_dns_set_server(
    int index,
    ffi.Pointer<zts_ip_addr> addr,
  ) {
    return _zts_dns_set_server(
      index,
      addr,
    );
  }

  late final _zts_dns_set_serverPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Uint8, ffi.Pointer<zts_ip_addr>)>>('zts_dns_set_server');
  late final _zts_dns_set_server = _zts_dns_set_serverPtr
      .asFunction<int Function(int, ffi.Pointer<zts_ip_addr>)>();

  /// Obtain one of the currently configured DNS server.
  ///
  /// @param index the index of the DNS server
  /// @return IP address of the indexed DNS server or `ip_addr_any` if the DNS
  /// server has not been configured.
  ffi.Pointer<zts_ip_addr> zts_dns_get_server(
    int index,
  ) {
    return _zts_dns_get_server(
      index,
    );
  }

  late final _zts_dns_get_serverPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<zts_ip_addr> Function(ffi.Uint8)>>(
          'zts_dns_get_server');
  late final _zts_dns_get_server = _zts_dns_get_serverPtr
      .asFunction<ffi.Pointer<zts_ip_addr> Function(int)>();

  /// @brief Lock the core service so that queries about addresses, routes, paths, etc. can be
  /// performed.
  ///
  /// Notice: Core locking functions are intended to be used by high-level language wrappers.
  /// Only lock the core if you know *exactly* what you are doing.
  ///
  /// @return `ZTS_ERR_OK` if successful. `ZTS_ERR_SERVICE` if the core service is unavailable.
  int zts_core_lock_obtain() {
    return _zts_core_lock_obtain();
  }

  late final _zts_core_lock_obtainPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('zts_core_lock_obtain');
  late final _zts_core_lock_obtain =
      _zts_core_lock_obtainPtr.asFunction<int Function()>();

  /// @brief Lock the core service so that queries about addresses, routes, paths, etc. can be
  /// performed.
  ///
  /// Notice: Core locking functions are intended to be used by high-level language wrappers.
  /// Only lock the core if you know *exactly* what you are doing.
  ///
  /// @return `ZTS_ERR_OK` if successful. `ZTS_ERR_SERVICE` if the core service is unavailable.
  int zts_core_lock_release() {
    return _zts_core_lock_release();
  }

  late final _zts_core_lock_releasePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('zts_core_lock_release');
  late final _zts_core_lock_release =
      _zts_core_lock_releasePtr.asFunction<int Function()>();

  /// @brief Lock the core service so that queries about addresses, routes, paths, etc. can be
  /// performed.
  ///
  /// Notice: Core locking functions are intended to be used by high-level language wrappers.
  /// Only lock the core if you know *exactly* what you are doing. zts_core_lock_obtain() and
  /// zts_core_lock_release() must be called before and after this function.
  ///
  /// @return `ZTS_ERR_OK` if successful. `ZTS_ERR_SERVICE` if the core service is unavailable.
  int zts_core_query_addr_count(
    int net_id,
  ) {
    return _zts_core_query_addr_count(
      net_id,
    );
  }

  late final _zts_core_query_addr_countPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64)>>(
          'zts_core_query_addr_count');
  late final _zts_core_query_addr_count =
      _zts_core_query_addr_countPtr.asFunction<int Function(int)>();

  /// @brief Lock the core service so that queries about addresses, routes, paths, etc. can be
  /// performed.
  ///
  /// Notice: Core locking functions are intended to be used by high-level language wrappers.
  /// Only lock the core if you know *exactly* what you are doing. zts_core_lock_obtain() and
  /// zts_core_lock_release() must be called before and after this function.
  ///
  /// @return `ZTS_ERR_OK` if successful. `ZTS_ERR_SERVICE` if the core service is unavailable.
  int zts_core_query_addr(
    int net_id,
    int idx,
    ffi.Pointer<ffi.Char> addr,
    int len,
  ) {
    return _zts_core_query_addr(
      net_id,
      idx,
      addr,
      len,
    );
  }

  late final _zts_core_query_addrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Uint64, ffi.UnsignedInt, ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('zts_core_query_addr');
  late final _zts_core_query_addr = _zts_core_query_addrPtr
      .asFunction<int Function(int, int, ffi.Pointer<ffi.Char>, int)>();

  /// @brief Lock the core service so that queries about addresses, routes, paths, etc. can be
  /// performed.
  ///
  /// Notice: Core locking functions are intended to be used by high-level language wrappers.
  /// Only lock the core if you know *exactly* what you are doing. zts_core_lock_obtain() and
  /// zts_core_lock_release() must be called before and after this function.
  ///
  /// @return `ZTS_ERR_OK` if successful. `ZTS_ERR_SERVICE` if the core service is unavailable.
  int zts_core_query_route_count(
    int net_id,
  ) {
    return _zts_core_query_route_count(
      net_id,
    );
  }

  late final _zts_core_query_route_countPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64)>>(
          'zts_core_query_route_count');
  late final _zts_core_query_route_count =
      _zts_core_query_route_countPtr.asFunction<int Function(int)>();

  /// @brief Lock the core service so that queries about addresses, routes, paths, etc. can be
  /// performed.
  ///
  /// Notice: Core locking functions are intended to be used by high-level language wrappers.
  /// Only lock the core if you know *exactly* what you are doing. zts_core_lock_obtain() and
  /// zts_core_lock_release() must be called before and after this function.
  ///
  /// @return `ZTS_ERR_OK` if successful. `ZTS_ERR_SERVICE` if the core service is unavailable.
  int zts_core_query_route(
    int net_id,
    int idx,
    ffi.Pointer<ffi.Char> target,
    ffi.Pointer<ffi.Char> via,
    int len,
    ffi.Pointer<ffi.Uint16> flags,
    ffi.Pointer<ffi.Uint16> metric,
  ) {
    return _zts_core_query_route(
      net_id,
      idx,
      target,
      via,
      len,
      flags,
      metric,
    );
  }

  late final _zts_core_query_routePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Uint64,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Uint16>,
              ffi.Pointer<ffi.Uint16>)>>('zts_core_query_route');
  late final _zts_core_query_route = _zts_core_query_routePtr.asFunction<
      int Function(int, int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int,
          ffi.Pointer<ffi.Uint16>, ffi.Pointer<ffi.Uint16>)>();

  /// @brief Lock the core service so that queries about addresses, routes, paths, etc. can be
  /// performed.
  ///
  /// Notice: Core locking functions are intended to be used by high-level language wrappers.
  /// Only lock the core if you know *exactly* what you are doing. zts_core_lock_obtain() and
  /// zts_core_lock_release() must be called before and after this function.
  ///
  /// @return `ZTS_ERR_OK` if successful. `ZTS_ERR_SERVICE` if the core service is unavailable.
  int zts_core_query_path_count(
    int peer_id,
  ) {
    return _zts_core_query_path_count(
      peer_id,
    );
  }

  late final _zts_core_query_path_countPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64)>>(
          'zts_core_query_path_count');
  late final _zts_core_query_path_count =
      _zts_core_query_path_countPtr.asFunction<int Function(int)>();

  /// @brief Lock the core service so that queries about addresses, routes, paths, etc. can be
  /// performed.
  ///
  /// Notice: Core locking functions are intended to be used by high-level language wrappers.
  /// Only lock the core if you know *exactly* what you are doing. zts_core_lock_obtain() and
  /// zts_core_lock_release() must be called before and after this function.
  ///
  /// @return `ZTS_ERR_OK` if successful. `ZTS_ERR_SERVICE` if the core service is unavailable.
  int zts_core_query_path(
    int peer_id,
    int idx,
    ffi.Pointer<ffi.Char> dst,
    int len,
  ) {
    return _zts_core_query_path(
      peer_id,
      idx,
      dst,
      len,
    );
  }

  late final _zts_core_query_pathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Uint64, ffi.UnsignedInt, ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('zts_core_query_path');
  late final _zts_core_query_path = _zts_core_query_pathPtr
      .asFunction<int Function(int, int, ffi.Pointer<ffi.Char>, int)>();

  /// @brief Lock the core service so that queries about addresses, routes, paths, etc. can be
  /// performed.
  ///
  /// Notice: Core locking functions are intended to be used by high-level language wrappers.
  /// Only lock the core if you know *exactly* what you are doing. zts_core_lock_obtain() and
  /// zts_core_lock_release() must be called before and after this function.
  ///
  /// @return `ZTS_ERR_OK` if successful. `ZTS_ERR_SERVICE` if the core service is unavailable.
  int zts_core_query_mc_count(
    int net_id,
  ) {
    return _zts_core_query_mc_count(
      net_id,
    );
  }

  late final _zts_core_query_mc_countPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Uint64)>>(
          'zts_core_query_mc_count');
  late final _zts_core_query_mc_count =
      _zts_core_query_mc_countPtr.asFunction<int Function(int)>();

  /// @brief Lock the core service so that queries about addresses, routes, paths, etc. can be
  /// performed.
  ///
  /// Notice: Core locking functions are intended to be used by high-level language wrappers.
  /// Only lock the core if you know *exactly* what you are doing. zts_core_lock_obtain() and
  /// zts_core_lock_release() must be called before and after this function.
  ///
  /// @return `ZTS_ERR_OK` if successful. `ZTS_ERR_SERVICE` if the core service is unavailable.
  int zts_core_query_mc(
    int net_id,
    int idx,
    ffi.Pointer<ffi.Uint64> mac,
    ffi.Pointer<ffi.Uint32> adi,
  ) {
    return _zts_core_query_mc(
      net_id,
      idx,
      mac,
      adi,
    );
  }

  late final _zts_core_query_mcPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Uint64, ffi.UnsignedInt, ffi.Pointer<ffi.Uint64>,
              ffi.Pointer<ffi.Uint32>)>>('zts_core_query_mc');
  late final _zts_core_query_mc = _zts_core_query_mcPtr.asFunction<
      int Function(
          int, int, ffi.Pointer<ffi.Uint64>, ffi.Pointer<ffi.Uint32>)>();

  /// @brief Generates a new root set definition
  ///
  /// @param roots_id The desired World ID (arbitrary)
  /// @param ts Timestamp indicating when this generation took place
  int zts_util_sign_root_set(
    ffi.Pointer<ffi.Char> roots_out,
    ffi.Pointer<ffi.UnsignedInt> roots_len,
    ffi.Pointer<ffi.Char> prev_key,
    ffi.Pointer<ffi.UnsignedInt> prev_key_len,
    ffi.Pointer<ffi.Char> curr_key,
    ffi.Pointer<ffi.UnsignedInt> curr_key_len,
    int id,
    int ts,
    ffi.Pointer<zts_root_set_t> roots_spec,
  ) {
    return _zts_util_sign_root_set(
      roots_out,
      roots_len,
      prev_key,
      prev_key_len,
      curr_key,
      curr_key_len,
      id,
      ts,
      roots_spec,
    );
  }

  late final _zts_util_sign_root_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Uint64,
              ffi.Uint64,
              ffi.Pointer<zts_root_set_t>)>>('zts_util_sign_root_set');
  late final _zts_util_sign_root_set = _zts_util_sign_root_setPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.UnsignedInt>,
          int,
          int,
          ffi.Pointer<zts_root_set_t>)>();

  /// @brief Platform-agnostic delay
  ///
  /// @param milliseconds How long to delay
  void zts_util_delay(
    int milliseconds,
  ) {
    return _zts_util_delay(
      milliseconds,
    );
  }

  late final _zts_util_delayPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedLong)>>(
          'zts_util_delay');
  late final _zts_util_delay =
      _zts_util_delayPtr.asFunction<void Function(int)>();

  /// @brief Return the family type of the IP string
  ///
  /// @param ipstr Either IPv4 or IPv6 string
  /// @return Either `ZTS_AF_INET` or `ZTS_AF_INET6`
  int zts_util_get_ip_family(
    ffi.Pointer<ffi.Char> ipstr,
  ) {
    return _zts_util_get_ip_family(
      ipstr,
    );
  }

  late final _zts_util_get_ip_familyPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'zts_util_get_ip_family');
  late final _zts_util_get_ip_family = _zts_util_get_ip_familyPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Convert human-friendly IP string to `zts_sockaddr_in` or `zts_sockaddr_in6`.
  ///
  /// @param src_ipstr Source IP string
  /// @param port Port
  /// @param dstaddr Pointer to destination structure `zts_sockaddr_in` or
  /// `zts_sockaddr_in6`
  /// @param addrlen Size of destination structure. Value-result: Will be set to
  /// actual size of data available
  /// @return return `ZTS_ERR_OK` on success, `ZTS_ERR_ARG` if invalid argument
  int zts_util_ipstr_to_saddr(
    ffi.Pointer<ffi.Char> src_ipstr,
    int port,
    ffi.Pointer<zts_sockaddr> dstaddr,
    ffi.Pointer<zts_socklen_t> addrlen,
  ) {
    return _zts_util_ipstr_to_saddr(
      src_ipstr,
      port,
      dstaddr,
      addrlen,
    );
  }

  late final _zts_util_ipstr_to_saddrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedShort,
              ffi.Pointer<zts_sockaddr>,
              ffi.Pointer<zts_socklen_t>)>>('zts_util_ipstr_to_saddr');
  late final _zts_util_ipstr_to_saddr = _zts_util_ipstr_to_saddrPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<zts_sockaddr>,
          ffi.Pointer<zts_socklen_t>)>();

  /// @brief Similar to `inet_ntop` but determines family automatically and returns
  /// port as a value result parameter.
  ///
  /// @param addr Pointer to address structure
  /// @param addrlen Length of address structure
  /// @param dst_str Destination buffer
  /// @param len Length of destination buffer
  /// @param port Value-result parameter that will contain resultant port number
  ///
  /// @return return `ZTS_ERR_OK` on success, `ZTS_ERR_ARG` if invalid argument
  int zts_util_ntop(
    ffi.Pointer<zts_sockaddr> addr,
    int addrlen,
    ffi.Pointer<ffi.Char> dst_str,
    int len,
    ffi.Pointer<ffi.UnsignedShort> port,
  ) {
    return _zts_util_ntop(
      addr,
      addrlen,
      dst_str,
      len,
      port,
    );
  }

  late final _zts_util_ntopPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<zts_sockaddr>,
              zts_socklen_t,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.UnsignedShort>)>>('zts_util_ntop');
  late final _zts_util_ntop = _zts_util_ntopPtr.asFunction<
      int Function(ffi.Pointer<zts_sockaddr>, int, ffi.Pointer<ffi.Char>, int,
          ffi.Pointer<ffi.UnsignedShort>)>();

  /// Convert numeric IP address (both versions) into `ASCII` representation.
  /// returns ptr to static buffer. Not reentrant.
  ///
  /// @param addr IP address in network order to convert
  /// @return Pointer to a global static (!) buffer that holds the `ASCII`
  /// representation of addr
  ffi.Pointer<ffi.Char> zts_ipaddr_ntoa(
    ffi.Pointer<zts_ip_addr> addr,
  ) {
    return _zts_ipaddr_ntoa(
      addr,
    );
  }

  late final _zts_ipaddr_ntoaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<zts_ip_addr>)>>('zts_ipaddr_ntoa');
  late final _zts_ipaddr_ntoa = _zts_ipaddr_ntoaPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<zts_ip_addr>)>();

  /// Convert IP address string (both versions) to numeric.
  /// The version is auto-detected from the string.
  ///
  /// @param cp IP address string to convert
  /// @param addr conversion result is stored here
  /// @return `1` on success, `0` on error
  int zts_ipaddr_aton(
    ffi.Pointer<ffi.Char> cp,
    ffi.Pointer<zts_ip_addr> addr,
  ) {
    return _zts_ipaddr_aton(
      cp,
      addr,
    );
  }

  late final _zts_ipaddr_atonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<zts_ip_addr>)>>('zts_ipaddr_aton');
  late final _zts_ipaddr_aton = _zts_ipaddr_atonPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<zts_ip_addr>)>();

  /// Convert IPv4 and IPv6 address structures to human-readable text form.
  ///
  /// @param family Address family: `ZTS_AF_INET` or `ZTS_AF_INET6`
  /// @param src Pointer to source address structure
  /// @param dst Pointer to destination character array
  /// @param size Size of the destination buffer
  /// @return On success, returns a non-null pointer to the destination character
  /// array
  ffi.Pointer<ffi.Char> zts_inet_ntop(
    int family,
    ffi.Pointer<ffi.Void> src,
    ffi.Pointer<ffi.Char> dst,
    int size,
  ) {
    return _zts_inet_ntop(
      family,
      src,
      dst,
      size,
    );
  }

  late final _zts_inet_ntopPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Int, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Char>, zts_socklen_t)>>('zts_inet_ntop');
  late final _zts_inet_ntop = _zts_inet_ntopPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          int, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, int)>();

  /// Convert C-string IPv4 and IPv6 addresses to binary form.
  ///
  /// @param family Address family: `ZTS_AF_INET` or `ZTS_AF_INET6`
  /// @param src Pointer to source character array
  /// @param dst Pointer to destination address structure
  /// @return return `1` on success. `0` or `-1` on failure. (Does not follow regular
  /// `zts_*` conventions)
  int zts_inet_pton(
    int family,
    ffi.Pointer<ffi.Char> src,
    ffi.Pointer<ffi.Void> dst,
  ) {
    return _zts_inet_pton(
      family,
      src,
      dst,
    );
  }

  late final _zts_inet_ptonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>)>>('zts_inet_pton');
  late final _zts_inet_pton = _zts_inet_ptonPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>)>();
}

/// Common error return values
enum zts_error_t {
  /// No error
  ZTS_ERR_OK(0),

  /// Socket error, see `zts_errno`
  ZTS_ERR_SOCKET(-1),

  /// This operation is not allowed at this time. Or possibly the node hasn't been started
  ZTS_ERR_SERVICE(-2),

  /// Invalid argument
  ZTS_ERR_ARG(-3),

  /// No result (not necessarily an error)
  ZTS_ERR_NO_RESULT(-4),

  /// Consider filing a bug report
  ZTS_ERR_GENERAL(-5);

  final int value;
  const zts_error_t(this.value);

  static zts_error_t fromValue(int value) => switch (value) {
        0 => ZTS_ERR_OK,
        -1 => ZTS_ERR_SOCKET,
        -2 => ZTS_ERR_SERVICE,
        -3 => ZTS_ERR_ARG,
        -4 => ZTS_ERR_NO_RESULT,
        -5 => ZTS_ERR_GENERAL,
        _ => throw ArgumentError("Unknown value for zts_error_t: $value"),
      };
}

/// Event codes used by the (optional) callback API
enum zts_event_t {
  /// Node has been initialized
  ///
  /// This is the first event generated, and is always sent. It may occur
  /// before node's constructor returns.
  ZTS_EVENT_NODE_UP(200),

  /// Node is online -- at least one upstream node appears reachable
  ZTS_EVENT_NODE_ONLINE(201),

  /// Node is offline -- network does not seem to be reachable by any available
  /// strategy
  ZTS_EVENT_NODE_OFFLINE(202),

  /// Node is shutting down
  ///
  /// This is generated within Node's destructor when it is being shut down.
  /// It's done for convenience, since cleaning up other state in the event
  /// handler may appear more idiomatic.
  ZTS_EVENT_NODE_DOWN(203),

  /// A fatal error has occurred. One possible reason is:
  ///
  /// Your identity has collided with another node's ZeroTier address
  ///
  /// This happens if two different public keys both hash (via the algorithm
  /// in Identity::generate()) to the same 40-bit ZeroTier address.
  ///
  /// This is something you should "never" see, where "never" is defined as
  /// once per 2^39 new node initializations / identity creations. If you do
  /// see it, you're going to see it very soon after a node is first
  /// initialized.
  ///
  /// This is reported as an event rather than a return code since it's
  /// detected asynchronously via error messages from authoritative nodes.
  ///
  /// If this occurs, you must shut down and delete the node, delete the
  /// identity.secret record/file from the data store, and restart to generate
  /// a new identity. If you don't do this, you will not be able to communicate
  /// with other nodes.
  ///
  /// We'd automate this process, but we don't think silently deleting
  /// private keys or changing our address without telling the calling code
  /// is good form. It violates the principle of least surprise.
  ///
  /// You can technically get away with not handling this, but we recommend
  /// doing so in a mature reliable application. Besides, handling this
  /// condition is a good way to make sure it never arises. It's like how
  /// umbrellas prevent rain and smoke detectors prevent fires. They do, right?
  ///
  /// Meta-data: none
  ZTS_EVENT_NODE_FATAL_ERROR(204),

  /// Network ID does not correspond to a known network
  ZTS_EVENT_NETWORK_NOT_FOUND(210),

  /// The version of ZeroTier inside libzt is too old
  ZTS_EVENT_NETWORK_CLIENT_TOO_OLD(211),

  /// The configuration for a network has been requested (no action needed)
  ZTS_EVENT_NETWORK_REQ_CONFIG(212),

  /// The node joined the network successfully (no action needed)
  ZTS_EVENT_NETWORK_OK(213),

  /// The node is not allowed to join the network (you must authorize node)
  ZTS_EVENT_NETWORK_ACCESS_DENIED(214),

  /// The node has received an IPv4 address from the network controller
  ZTS_EVENT_NETWORK_READY_IP4(215),

  /// The node has received an IPv6 address from the network controller
  ZTS_EVENT_NETWORK_READY_IP6(216),

  /// Deprecated
  ZTS_EVENT_NETWORK_READY_IP4_IP6(217),

  /// Network controller is unreachable
  ZTS_EVENT_NETWORK_DOWN(218),

  /// Network change received from controller
  ZTS_EVENT_NETWORK_UPDATE(219),

  /// TCP/IP stack (lwIP) is up (for debug purposes)
  ZTS_EVENT_STACK_UP(220),

  /// TCP/IP stack (lwIP) id down (for debug purposes)
  ZTS_EVENT_STACK_DOWN(221),

  /// lwIP netif up (for debug purposes)
  ZTS_EVENT_NETIF_UP(230),

  /// lwIP netif down (for debug purposes)
  ZTS_EVENT_NETIF_DOWN(231),

  /// lwIP netif removed (for debug purposes)
  ZTS_EVENT_NETIF_REMOVED(232),

  /// lwIP netif link up (for debug purposes)
  ZTS_EVENT_NETIF_LINK_UP(233),

  /// lwIP netif link down (for debug purposes)
  ZTS_EVENT_NETIF_LINK_DOWN(234),

  /// A direct P2P path to peer is known
  ZTS_EVENT_PEER_DIRECT(240),

  /// A direct P2P path to peer is NOT known. Traffic is now relayed
  ZTS_EVENT_PEER_RELAY(241),

  /// A peer is unreachable. Check NAT/Firewall settings
  ZTS_EVENT_PEER_UNREACHABLE(242),

  /// A new path to a peer was discovered
  ZTS_EVENT_PEER_PATH_DISCOVERED(243),

  /// A known path to a peer is now considered dead
  ZTS_EVENT_PEER_PATH_DEAD(244),

  /// A new managed network route was added
  ZTS_EVENT_ROUTE_ADDED(250),

  /// A managed network route was removed
  ZTS_EVENT_ROUTE_REMOVED(251),

  /// A new managed IPv4 address was assigned to this peer
  ZTS_EVENT_ADDR_ADDED_IP4(260),

  /// A managed IPv4 address assignment was removed from this peer
  ZTS_EVENT_ADDR_REMOVED_IP4(261),

  /// A new managed IPv4 address was assigned to this peer
  ZTS_EVENT_ADDR_ADDED_IP6(262),

  /// A managed IPv6 address assignment was removed from this peer
  ZTS_EVENT_ADDR_REMOVED_IP6(263),

  /// The node's secret key (identity)
  ZTS_EVENT_STORE_IDENTITY_SECRET(270),

  /// The node's public key (identity)
  ZTS_EVENT_STORE_IDENTITY_PUBLIC(271),

  /// The node has received an updated planet config
  ZTS_EVENT_STORE_PLANET(272),

  /// New reachability hints and peer configuration
  ZTS_EVENT_STORE_PEER(273),

  /// New network config
  ZTS_EVENT_STORE_NETWORK(274);

  final int value;
  const zts_event_t(this.value);

  static zts_event_t fromValue(int value) => switch (value) {
        200 => ZTS_EVENT_NODE_UP,
        201 => ZTS_EVENT_NODE_ONLINE,
        202 => ZTS_EVENT_NODE_OFFLINE,
        203 => ZTS_EVENT_NODE_DOWN,
        204 => ZTS_EVENT_NODE_FATAL_ERROR,
        210 => ZTS_EVENT_NETWORK_NOT_FOUND,
        211 => ZTS_EVENT_NETWORK_CLIENT_TOO_OLD,
        212 => ZTS_EVENT_NETWORK_REQ_CONFIG,
        213 => ZTS_EVENT_NETWORK_OK,
        214 => ZTS_EVENT_NETWORK_ACCESS_DENIED,
        215 => ZTS_EVENT_NETWORK_READY_IP4,
        216 => ZTS_EVENT_NETWORK_READY_IP6,
        217 => ZTS_EVENT_NETWORK_READY_IP4_IP6,
        218 => ZTS_EVENT_NETWORK_DOWN,
        219 => ZTS_EVENT_NETWORK_UPDATE,
        220 => ZTS_EVENT_STACK_UP,
        221 => ZTS_EVENT_STACK_DOWN,
        230 => ZTS_EVENT_NETIF_UP,
        231 => ZTS_EVENT_NETIF_DOWN,
        232 => ZTS_EVENT_NETIF_REMOVED,
        233 => ZTS_EVENT_NETIF_LINK_UP,
        234 => ZTS_EVENT_NETIF_LINK_DOWN,
        240 => ZTS_EVENT_PEER_DIRECT,
        241 => ZTS_EVENT_PEER_RELAY,
        242 => ZTS_EVENT_PEER_UNREACHABLE,
        243 => ZTS_EVENT_PEER_PATH_DISCOVERED,
        244 => ZTS_EVENT_PEER_PATH_DEAD,
        250 => ZTS_EVENT_ROUTE_ADDED,
        251 => ZTS_EVENT_ROUTE_REMOVED,
        260 => ZTS_EVENT_ADDR_ADDED_IP4,
        261 => ZTS_EVENT_ADDR_REMOVED_IP4,
        262 => ZTS_EVENT_ADDR_ADDED_IP6,
        263 => ZTS_EVENT_ADDR_REMOVED_IP6,
        270 => ZTS_EVENT_STORE_IDENTITY_SECRET,
        271 => ZTS_EVENT_STORE_IDENTITY_PUBLIC,
        272 => ZTS_EVENT_STORE_PLANET,
        273 => ZTS_EVENT_STORE_PEER,
        274 => ZTS_EVENT_STORE_NETWORK,
        _ => throw ArgumentError("Unknown value for zts_event_t: $value"),
      };
}

enum zts_errno_t {
  /// Operation not permitted
  ZTS_EPERM(1),

  /// No such file or directory
  ZTS_ENOENT(2),

  /// No such process
  ZTS_ESRCH(3),

  /// Interrupted system call
  ZTS_EINTR(4),

  /// I/O error
  ZTS_EIO(5),

  /// No such device or address
  ZTS_ENXIO(6),

  /// Bad file number
  ZTS_EBADF(9),

  /// Try again
  ZTS_EAGAIN(11),

  /// Out of memory
  ZTS_ENOMEM(12),

  /// Permission denied
  ZTS_EACCES(13),

  /// Bad address
  ZTS_EFAULT(14),

  /// Device or resource busy
  ZTS_EBUSY(16),

  /// File exists
  ZTS_EEXIST(17),

  /// No such device
  ZTS_ENODEV(19),

  /// Invalid argument
  ZTS_EINVAL(22),

  /// File table overflow
  ZTS_ENFILE(23),

  /// Too many open files
  ZTS_EMFILE(24),

  /// Function not implemented
  ZTS_ENOSYS(38),

  /// Socket operation on non-socket
  ZTS_ENOTSOCK(88),

  /// Destination address required
  ZTS_EDESTADDRREQ(89),

  /// Message too long
  ZTS_EMSGSIZE(90),

  /// Protocol wrong type for socket
  ZTS_EPROTOTYPE(91),

  /// Protocol not available
  ZTS_ENOPROTOOPT(92),

  /// Protocol not supported
  ZTS_EPROTONOSUPPORT(93),

  /// Socket type not supported
  ZTS_ESOCKTNOSUPPORT(94),

  /// Operation not supported on transport endpoint
  ZTS_EOPNOTSUPP(95),

  /// Protocol family not supported
  ZTS_EPFNOSUPPORT(96),

  /// Address family not supported by protocol
  ZTS_EAFNOSUPPORT(97),

  /// Address already in use
  ZTS_EADDRINUSE(98),

  /// Cannot assign requested address
  ZTS_EADDRNOTAVAIL(99),

  /// Network is down
  ZTS_ENETDOWN(100),

  /// Network is unreachable
  ZTS_ENETUNREACH(101),

  /// Software caused connection abort
  ZTS_ECONNABORTED(103),

  /// Connection reset by peer
  ZTS_ECONNRESET(104),

  /// No buffer space available
  ZTS_ENOBUFS(105),

  /// Transport endpoint is already connected
  ZTS_EISCONN(106),

  /// Transport endpoint is not connected
  ZTS_ENOTCONN(107),

  /// Connection timed out
  ZTS_ETIMEDOUT(110),

  /// Connection refused
  ZTS_ECONNREFUSED(111),

  /// No route to host
  ZTS_EHOSTUNREACH(113),

  /// Operation already in progress
  ZTS_EALREADY(114),

  /// Operation now in progress
  ZTS_EINPROGRESS(115);

  /// Operation would block
  static const ZTS_EWOULDBLOCK = ZTS_EAGAIN;

  final int value;
  const zts_errno_t(this.value);

  static zts_errno_t fromValue(int value) => switch (value) {
        1 => ZTS_EPERM,
        2 => ZTS_ENOENT,
        3 => ZTS_ESRCH,
        4 => ZTS_EINTR,
        5 => ZTS_EIO,
        6 => ZTS_ENXIO,
        9 => ZTS_EBADF,
        11 => ZTS_EAGAIN,
        12 => ZTS_ENOMEM,
        13 => ZTS_EACCES,
        14 => ZTS_EFAULT,
        16 => ZTS_EBUSY,
        17 => ZTS_EEXIST,
        19 => ZTS_ENODEV,
        22 => ZTS_EINVAL,
        23 => ZTS_ENFILE,
        24 => ZTS_EMFILE,
        38 => ZTS_ENOSYS,
        88 => ZTS_ENOTSOCK,
        89 => ZTS_EDESTADDRREQ,
        90 => ZTS_EMSGSIZE,
        91 => ZTS_EPROTOTYPE,
        92 => ZTS_ENOPROTOOPT,
        93 => ZTS_EPROTONOSUPPORT,
        94 => ZTS_ESOCKTNOSUPPORT,
        95 => ZTS_EOPNOTSUPP,
        96 => ZTS_EPFNOSUPPORT,
        97 => ZTS_EAFNOSUPPORT,
        98 => ZTS_EADDRINUSE,
        99 => ZTS_EADDRNOTAVAIL,
        100 => ZTS_ENETDOWN,
        101 => ZTS_ENETUNREACH,
        103 => ZTS_ECONNABORTED,
        104 => ZTS_ECONNRESET,
        105 => ZTS_ENOBUFS,
        106 => ZTS_EISCONN,
        107 => ZTS_ENOTCONN,
        110 => ZTS_ETIMEDOUT,
        111 => ZTS_ECONNREFUSED,
        113 => ZTS_EHOSTUNREACH,
        114 => ZTS_EALREADY,
        115 => ZTS_EINPROGRESS,
        _ => throw ArgumentError("Unknown value for zts_errno_t: $value"),
      };

  @override
  String toString() {
    if (this == ZTS_EAGAIN)
      return "zts_errno_t.ZTS_EAGAIN, zts_errno_t.ZTS_EWOULDBLOCK";
    return super.toString();
  }
}

/// mbstate_t is an opaque object to keep conversion state, during multibyte
/// stream conversions.  The content must not be referenced by user programs.
final class __mbstate_t extends ffi.Union {
  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> __mbstate8;

  /// for alignment
  @ffi.LongLong()
  external int _mbstateL;
}

final class __darwin_pthread_handler_rec extends ffi.Struct {
  /// Routine to call
  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      __routine;

  /// Argument to pass
  external ffi.Pointer<ffi.Void> __arg;

  external ffi.Pointer<__darwin_pthread_handler_rec> __next;
}

final class _opaque_pthread_attr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_cond_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([40])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_condattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_mutex_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_mutexattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_once_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_rwlock_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([192])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_rwlockattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  external ffi.Pointer<__darwin_pthread_handler_rec> __cleanup_stack;

  @ffi.Array.multi([8176])
  external ffi.Array<ffi.Char> __opaque;
}

final class accessx_descriptor extends ffi.Struct {
  @ffi.UnsignedInt()
  external int ad_name_offset;

  @ffi.Int()
  external int ad_flags;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.Int> ad_pad;
}

typedef ssize_t = __darwin_ssize_t;
typedef __darwin_ssize_t = ffi.Long;
typedef Dart__darwin_ssize_t = int;
typedef uid_t = __darwin_uid_t;
typedef __darwin_uid_t = __uint32_t;
typedef __uint32_t = ffi.UnsignedInt;
typedef Dart__uint32_t = int;
typedef gid_t = __darwin_gid_t;
typedef __darwin_gid_t = __uint32_t;
typedef pid_t = __darwin_pid_t;
typedef __darwin_pid_t = __int32_t;
typedef __int32_t = ffi.Int;
typedef Dart__int32_t = int;
typedef off_t = __darwin_off_t;
typedef __darwin_off_t = __int64_t;
typedef __int64_t = ffi.LongLong;
typedef Dart__int64_t = int;
typedef useconds_t = __darwin_useconds_t;
typedef __darwin_useconds_t = __uint32_t;

final class fd_set extends ffi.Struct {
  @ffi.Array.multi([32])
  external ffi.Array<__int32_t> fds_bits;
}

final class timespec extends ffi.Struct {
  @__darwin_time_t()
  external int tv_sec;

  @ffi.Long()
  external int tv_nsec;
}

typedef __darwin_time_t = ffi.Long;
typedef Dart__darwin_time_t = int;

final class timeval extends ffi.Struct {
  /// seconds
  @__darwin_time_t()
  external int tv_sec;

  /// and microseconds
  @__darwin_suseconds_t()
  external int tv_usec;
}

typedef __darwin_suseconds_t = __int32_t;
typedef sigset_t = __darwin_sigset_t;
typedef __darwin_sigset_t = __uint32_t;
typedef mode_t = __darwin_mode_t;
typedef __darwin_mode_t = __uint16_t;
typedef __uint16_t = ffi.UnsignedShort;
typedef Dart__uint16_t = int;
typedef dev_t = __darwin_dev_t;
typedef __darwin_dev_t = __int32_t;

final class fssearchblock extends ffi.Opaque {}

final class searchstate extends ffi.Opaque {}

final class zts_in_addr extends ffi.Struct {
  /// A definition in winsock may conflict with s_addr
  @zts_in_addr_t()
  external int s_addr;
}

typedef zts_in_addr_t = ffi.Uint32;
typedef Dartzts_in_addr_t = int;

final class zts_in6_addr extends ffi.Struct {
  external un un1;
}

final class un extends ffi.Union {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Uint32> u32_addr;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> u8_addr;
}

/// Address structure to specify an IPv4 endpoint
final class zts_sockaddr_in extends ffi.Struct {
  @ffi.Uint8()
  external int sin_len;

  @zts_sa_family_t()
  external int sin_family;

  @zts_in_port_t()
  external int sin_port;

  external zts_in_addr sin_addr;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> sin_zero;
}

typedef zts_sa_family_t = ffi.Uint8;
typedef Dartzts_sa_family_t = int;
typedef zts_in_port_t = ffi.Uint16;
typedef Dartzts_in_port_t = int;

/// Address structure to specify an IPv6 endpoint
final class zts_sockaddr_in6 extends ffi.Struct {
  /// length of this structure
  @ffi.Uint8()
  external int sin6_len;

  /// ZTS_AF_INET6
  @zts_sa_family_t()
  external int sin6_family;

  /// Transport layer port #
  @zts_in_port_t()
  external int sin6_port;

  /// IPv6 flow information
  @ffi.Uint32()
  external int sin6_flowinfo;

  /// IPv6 address
  external zts_in6_addr sin6_addr;

  /// Set of interfaces for scope
  @ffi.Uint32()
  external int sin6_scope_id;
}

/// Pointers to socket address structures are often cast to this type
final class zts_sockaddr extends ffi.Struct {
  @ffi.Uint8()
  external int sa_len;

  @zts_sa_family_t()
  external int sa_family;

  @ffi.Array.multi([14])
  external ffi.Array<ffi.Char> sa_data;
}

/// Address structure large enough to hold IPv4 and IPv6 addresses
final class zts_sockaddr_storage extends ffi.Struct {
  @ffi.Uint8()
  external int s2_len;

  @zts_sa_family_t()
  external int ss_family;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.Char> s2_data1;

  @ffi.Array.multi([3])
  external ffi.Array<ffi.Uint32> s2_data2;

  @ffi.Array.multi([3])
  external ffi.Array<ffi.Uint32> s2_data3;
}

/// Runtime details about the current node
final class zts_node_info_t extends ffi.Struct {
  /// Node ID
  @ffi.Uint64()
  external int node_id;

  /// Port used by ZeroTier to send and receive traffic
  @ffi.Uint16()
  external int port_primary;

  /// Port used by ZeroTier to send and receive traffic
  @ffi.Uint16()
  external int port_secondary;

  /// Port used by ZeroTier to send and receive traffic
  @ffi.Uint16()
  external int port_tertiary;

  /// ZT Major version
  @ffi.Uint8()
  external int ver_major;

  /// ZT Minor version
  @ffi.Uint8()
  external int ver_minor;

  /// ZT Patch revision
  @ffi.Uint8()
  external int ver_rev;
}

/// Details about an assigned address that was added or removed
final class zts_addr_info_t extends ffi.Struct {
  @ffi.Uint64()
  external int net_id;

  external zts_sockaddr_storage addr;
}

/// Virtual network status codes
enum zts_network_status_t {
  /// Waiting for network configuration (also means revision == 0)
  ZTS_NETWORK_STATUS_REQUESTING_CONFIGURATION(0),

  /// Configuration received and we are authorized
  ZTS_NETWORK_STATUS_OK(1),

  /// Netconf master told us 'nope'
  ZTS_NETWORK_STATUS_ACCESS_DENIED(2),

  /// Netconf master exists, but this virtual network does not
  ZTS_NETWORK_STATUS_NOT_FOUND(3),

  /// Initialization of network failed or other internal error
  ZTS_NETWORK_STATUS_PORT_ERROR(4),

  /// ZeroTier core version too old
  ZTS_NETWORK_STATUS_CLIENT_TOO_OLD(5);

  final int value;
  const zts_network_status_t(this.value);

  static zts_network_status_t fromValue(int value) => switch (value) {
        0 => ZTS_NETWORK_STATUS_REQUESTING_CONFIGURATION,
        1 => ZTS_NETWORK_STATUS_OK,
        2 => ZTS_NETWORK_STATUS_ACCESS_DENIED,
        3 => ZTS_NETWORK_STATUS_NOT_FOUND,
        4 => ZTS_NETWORK_STATUS_PORT_ERROR,
        5 => ZTS_NETWORK_STATUS_CLIENT_TOO_OLD,
        _ =>
          throw ArgumentError("Unknown value for zts_network_status_t: $value"),
      };
}

/// Virtual network type codes
enum zts_net_info_type_t {
  /// Private networks are authorized via certificates of membership
  ZTS_NETWORK_TYPE_PRIVATE(0),

  /// Public networks have no access control -- they'll always be AUTHORIZED
  ZTS_NETWORK_TYPE_PUBLIC(1);

  final int value;
  const zts_net_info_type_t(this.value);

  static zts_net_info_type_t fromValue(int value) => switch (value) {
        0 => ZTS_NETWORK_TYPE_PRIVATE,
        1 => ZTS_NETWORK_TYPE_PUBLIC,
        _ =>
          throw ArgumentError("Unknown value for zts_net_info_type_t: $value"),
      };
}

/// A route to be pushed on a virtual network
final class zts_route_info_t extends ffi.Struct {
  /// Target network / netmask bits (in port field) or NULL or 0.0.0.0/0
  /// for default
  external zts_sockaddr_storage target;

  /// Gateway IP address (port ignored) or NULL (family == 0) for LAN-local
  /// (no gateway)
  external zts_sockaddr_storage via;

  /// Route flags
  @ffi.Uint16()
  external int flags;

  /// Route metric (not currently used)
  @ffi.Uint16()
  external int metric;
}

/// An Ethernet multicast group
final class zts_multicast_group_t extends ffi.Struct {
  /// MAC address (least significant 48 bits)
  @ffi.Uint64()
  external int mac;

  /// Additional distinguishing information (usually zero)
  @ffi.UnsignedLong()
  external int adi;
}

/// The peer's trust hierarchy role
enum zts_peer_role_t {
  /// Ordinary node
  ZTS_PEER_ROLE_LEAF(0),

  /// Moon root
  ZTS_PEER_ROLE_MOON(1),

  /// Planetary root
  ZTS_PEER_ROLE_PLANET(2);

  final int value;
  const zts_peer_role_t(this.value);

  static zts_peer_role_t fromValue(int value) => switch (value) {
        0 => ZTS_PEER_ROLE_LEAF,
        1 => ZTS_PEER_ROLE_MOON,
        2 => ZTS_PEER_ROLE_PLANET,
        _ => throw ArgumentError("Unknown value for zts_peer_role_t: $value"),
      };
}

/// Virtual network configuration
final class zts_net_info_t extends ffi.Struct {
  /// 64-bit ZeroTier network ID
  @ffi.Uint64()
  external int net_id;

  /// Ethernet MAC (48 bits) that should be assigned to port
  @ffi.Uint64()
  external int mac;

  /// Network name (from network configuration master)
  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> name;

  /// Network configuration request status
  @ffi.UnsignedInt()
  external int status;

  /// Network type
  @ffi.UnsignedInt()
  external int type;

  /// Maximum interface MTU
  @ffi.UnsignedInt()
  external int mtu;

  /// If nonzero, the network this port belongs to indicates DHCP availability
  ///
  /// This is a suggestion. The underlying implementation is free to ignore it
  /// for security or other reasons. This is simply a netconf parameter that
  /// means 'DHCP is available on this network.'
  @ffi.Int()
  external int dhcp;

  /// If nonzero, this port is allowed to bridge to other networks
  ///
  /// This is informational. If this is false (0), bridged packets will simply
  /// be dropped and bridging won't work.
  @ffi.Int()
  external int bridge;

  /// If nonzero, this network supports and allows broadcast
  /// (ff:ff:ff:ff:ff:ff) traffic
  @ffi.Int()
  external int broadcast_enabled;

  /// If the network is in PORT_ERROR state, this is the (negative) error code
  /// most recently reported
  @ffi.Int()
  external int port_error;

  /// Revision number as reported by controller or 0 if still waiting for
  /// config
  @ffi.UnsignedLong()
  external int netconf_rev;

  /// Number of assigned addresses
  @ffi.UnsignedInt()
  external int assigned_addr_count;

  /// ZeroTier-assigned addresses (in sockaddr_storage structures)
  ///
  /// For IP, the port number of the sockaddr_XX structure contains the number
  /// of bits in the address netmask. Only the IP address and port are used.
  /// Other fields like interface number can be ignored.
  ///
  /// This is only used for ZeroTier-managed address assignments sent by the
  /// virtual network's configuration master.
  @ffi.Array.multi([16])
  external ffi.Array<zts_sockaddr_storage> assigned_addrs;

  /// Number of ZT-pushed routes
  @ffi.UnsignedInt()
  external int route_count;

  /// Routes (excluding those implied by assigned addresses and their masks)
  @ffi.Array.multi([32])
  external ffi.Array<zts_route_info_t> routes;

  /// Number of multicast groups subscribed
  @ffi.UnsignedInt()
  external int multicast_sub_count;

  @ffi.Array.multi([1024])
  external ffi.Array<UnnamedStruct1> multicast_subs;
}

/// Multicast groups to which this network's device is subscribed
final class UnnamedStruct1 extends ffi.Struct {
  /// MAC in lower 48 bits
  @ffi.Uint64()
  external int mac;

  /// Additional distinguishing information, usually zero
  /// except for IPv4 ARP groups
  @ffi.Uint32()
  external int adi;
}

/// Physical network path to a peer
final class zts_path_t extends ffi.Struct {
  /// Address of endpoint
  external zts_sockaddr_storage address;

  /// Time of last send in milliseconds or 0 for never
  @ffi.Uint64()
  external int last_tx;

  /// Time of last receive in milliseconds or 0 for never
  @ffi.Uint64()
  external int last_rx;

  /// Is this a trusted path? If so this will be its nonzero ID.
  @ffi.Uint64()
  external int trusted_path_id;

  /// One-way latency
  @ffi.Float()
  external double latency;

  @ffi.Float()
  external double unused_0;

  @ffi.Float()
  external double unused_1;

  @ffi.Float()
  external double unused_2;

  @ffi.Float()
  external double unused_3;

  @ffi.Float()
  external double unused_4;

  @ffi.Uint64()
  external int unused_5;

  @ffi.Uint64()
  external int unused_6;

  @ffi.Float()
  external double unused_7;

  /// Name of physical interface (for monitoring)
  external ffi.Pointer<ffi.Char> ifname;

  /// Is path expired?
  @ffi.Int()
  external int expired;

  /// Is path preferred?
  @ffi.Int()
  external int preferred;
}

/// Peer status result buffer
final class zts_peer_info_t extends ffi.Struct {
  /// ZeroTier address (40 bits)
  @ffi.Uint64()
  external int peer_id;

  /// Remote major version or -1 if not known
  @ffi.Int()
  external int ver_major;

  /// Remote minor version or -1 if not known
  @ffi.Int()
  external int ver_minor;

  /// Remote revision or -1 if not known
  @ffi.Int()
  external int ver_rev;

  /// Last measured latency in milliseconds or -1 if unknown
  @ffi.Int()
  external int latency;

  /// What trust hierarchy role does this device have?
  @ffi.UnsignedInt()
  external int role;

  /// Number of paths (size of paths[])
  @ffi.UnsignedInt()
  external int path_count;

  /// Whether this peer was ever reachable via an aggregate link
  @ffi.Int()
  external int unused_0;

  /// Known network paths to peer
  @ffi.Array.multi([64])
  external ffi.Array<zts_path_t> paths;
}

/// Structure used to specify a root topology (aka a world)
final class zts_root_set_t extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Pointer<ffi.Char>> public_id_str;

  @ffi.Array.multi([16, 32])
  external ffi.Array<ffi.Array<ffi.Pointer<ffi.Char>>> endpoint_ip_str;
}

/// Structure used to convey information about a virtual network
/// interface (netif) to a user application.
final class zts_netif_info_t extends ffi.Struct {
  /// The virtual network that this interface was created for
  @ffi.Uint64()
  external int net_id;

  /// The hardware address assigned to this interface
  @ffi.Uint64()
  external int mac;

  /// The MTU for this interface
  @ffi.Int()
  external int mtu;
}

/// Callback message
final class zts_event_msg_t extends ffi.Struct {
  /// Event identifier
  @ffi.Int16()
  external int event_code;

  /// Node status
  external ffi.Pointer<zts_node_info_t> node;

  /// Network information
  external ffi.Pointer<zts_net_info_t> network;

  /// Netif status
  external ffi.Pointer<zts_netif_info_t> netif;

  /// Managed routes
  external ffi.Pointer<zts_route_info_t> route;

  /// Peer info
  external ffi.Pointer<zts_peer_info_t> peer;

  /// Assigned address
  external ffi.Pointer<zts_addr_info_t> addr;

  /// Binary data (identities, planets, network configs, peer hints, etc)
  external ffi.Pointer<ffi.Void> cache;

  /// Length of data message or structure
  @ffi.Int()
  external int len;
}

/// Structure containing counters for various protocol statistics
final class zts_stats_counter_t extends ffi.Struct {
  /// Number of link packets transmitted
  @ffi.Uint32()
  external int link_tx;

  /// Number of link packets received
  @ffi.Uint32()
  external int link_rx;

  /// Number of link packets dropped
  @ffi.Uint32()
  external int link_drop;

  /// Aggregate number of link-level errors
  @ffi.Uint32()
  external int link_err;

  /// Number of etharp packets transmitted
  @ffi.Uint32()
  external int etharp_tx;

  /// Number of etharp packets received
  @ffi.Uint32()
  external int etharp_rx;

  /// Number of etharp packets dropped
  @ffi.Uint32()
  external int etharp_drop;

  /// Aggregate number of etharp errors
  @ffi.Uint32()
  external int etharp_err;

  /// Number of IPv4 packets transmitted
  @ffi.Uint32()
  external int ip4_tx;

  /// Number of IPv4 packets received
  @ffi.Uint32()
  external int ip4_rx;

  /// Number of IPv4 packets dropped
  @ffi.Uint32()
  external int ip4_drop;

  /// Aggregate number of IPv4 errors
  @ffi.Uint32()
  external int ip4_err;

  /// Number of IPv6 packets transmitted
  @ffi.Uint32()
  external int ip6_tx;

  /// Number of IPv6 packets received
  @ffi.Uint32()
  external int ip6_rx;

  /// Number of IPv6 packets dropped
  @ffi.Uint32()
  external int ip6_drop;

  /// Aggregate number of IPv6 errors
  @ffi.Uint32()
  external int ip6_err;

  /// Number of ICMPv4 packets transmitted
  @ffi.Uint32()
  external int icmp4_tx;

  /// Number of ICMPv4 packets received
  @ffi.Uint32()
  external int icmp4_rx;

  /// Number of ICMPv4 packets dropped
  @ffi.Uint32()
  external int icmp4_drop;

  /// Aggregate number of ICMPv4 errors
  @ffi.Uint32()
  external int icmp4_err;

  /// Number of ICMPv6 packets transmitted
  @ffi.Uint32()
  external int icmp6_tx;

  /// Number of ICMPv6 packets received
  @ffi.Uint32()
  external int icmp6_rx;

  /// Number of ICMPv6 packets dropped
  @ffi.Uint32()
  external int icmp6_drop;

  /// Aggregate number of ICMPv6 errors
  @ffi.Uint32()
  external int icmp6_err;

  /// Number of UDP packets transmitted
  @ffi.Uint32()
  external int udp_tx;

  /// Number of UDP packets received
  @ffi.Uint32()
  external int udp_rx;

  /// Number of UDP packets dropped
  @ffi.Uint32()
  external int udp_drop;

  /// Aggregate number of UDP errors
  @ffi.Uint32()
  external int udp_err;

  /// Number of TCP packets transmitted
  @ffi.Uint32()
  external int tcp_tx;

  /// Number of TCP packets received
  @ffi.Uint32()
  external int tcp_rx;

  /// Number of TCP packets dropped
  @ffi.Uint32()
  external int tcp_drop;

  /// Aggregate number of TCP errors
  @ffi.Uint32()
  external int tcp_err;

  /// Number of ND6 packets transmitted
  @ffi.Uint32()
  external int nd6_tx;

  /// Number of ND6 packets received
  @ffi.Uint32()
  external int nd6_rx;

  /// Number of ND6 packets dropped
  @ffi.Uint32()
  external int nd6_drop;

  /// Aggregate number of ND6 errors
  @ffi.Uint32()
  external int nd6_err;
}

/// ----------------------------------------------------------------------------//
/// Custom but still mostly standard socket interface structures               //
/// ----------------------------------------------------------------------------//
typedef zts_socklen_t = ffi.Uint32;
typedef Dartzts_socklen_t = int;

/// Structure used for manipulating linger option.
final class zts_linger extends ffi.Struct {
  /// option on/off
  @ffi.Int()
  external int l_onoff;

  /// linger time in seconds
  @ffi.Int()
  external int l_linger;
}

final class zts_ip_mreq extends ffi.Struct {
  /// IP multicast address of group
  external zts_in_addr imr_multiaddr;

  /// local IP address of interface
  external zts_in_addr imr_interface;
}

final class zts_in_pktinfo extends ffi.Struct {
  /// Interface index
  @ffi.UnsignedInt()
  external int ipi_ifindex;

  /// Destination (from header) address
  external zts_in_addr ipi_addr;
}

final class zts_ipv6_mreq extends ffi.Struct {
  /// IPv6 multicast addr
  external zts_in6_addr ipv6mr_multiaddr;

  /// interface index, or 0
  @ffi.UnsignedInt()
  external int ipv6mr_interface;
}

final class zts_fd_set extends ffi.Struct {
  @ffi.Array.multi([128])
  external ffi.Array<ffi.UnsignedChar> fd_bits;
}

final class zts_timeval extends ffi.Struct {
  /// seconds
  @ffi.Long()
  external int tv_sec;

  /// and microseconds
  @ffi.Long()
  external int tv_usec;
}

final class zts_pollfd extends ffi.Struct {
  @ffi.Int()
  external int fd;

  @ffi.Short()
  external int events;

  @ffi.Short()
  external int revents;
}

typedef zts_nfds_t = ffi.UnsignedInt;
typedef Dartzts_nfds_t = int;

final class zts_iovec extends ffi.Struct {
  external ffi.Pointer<ffi.Void> iov_base;

  @ffi.Size()
  external int iov_len;
}

///
final class zts_msghdr extends ffi.Struct {
  external ffi.Pointer<ffi.Void> msg_name;

  @zts_socklen_t()
  external int msg_namelen;

  external ffi.Pointer<zts_iovec> msg_iov;

  @ffi.Int()
  external int msg_iovlen;

  external ffi.Pointer<ffi.Void> msg_control;

  @zts_socklen_t()
  external int msg_controllen;

  @ffi.Int()
  external int msg_flags;
}

/// ----------------------------------------------------------------------------//
/// DNS                                                                        //
/// ----------------------------------------------------------------------------//
final class zts_hostent extends ffi.Struct {
  /// Official name of the host.
  external ffi.Pointer<ffi.Char> h_name;

  /// A pointer to an array of pointers to alternative host
  /// names,   terminated by a null pointer.
  external ffi.Pointer<ffi.Pointer<ffi.Char>> h_aliases;

  /// Address type.
  @ffi.Int()
  external int h_addrtype;

  /// The length, in bytes, of the address.
  @ffi.Int()
  external int h_length;

  /// A pointer to an array of pointers to network
  /// addresses (in network byte order) for the host,
  /// terminated by a null pointer.
  external ffi.Pointer<ffi.Pointer<ffi.Char>> h_addr_list;
}

final class zts_ip4_addr extends ffi.Struct {
  @ffi.Uint32()
  external int addr;
}

/// This is the aligned version of ip6_addr_t,
/// used as local variable, on the stack, etc.
final class zts_ip6_addr extends ffi.Struct {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Uint32> addr;
}

/// A union struct for both IP version's addresses.
/// ATTENTION: watch out for its size when adding IPv6 address scope!
final class zts_ip_addr extends ffi.Struct {
  external UnnamedUnion1 u_addr;

  /// ZTS_IPADDR_TYPE_V4, ZTS_IPADDR_TYPE_V6
  @ffi.Uint8()
  external int type;
}

final class UnnamedUnion1 extends ffi.Union {
  external zts_ip6_addr ip6;

  external zts_ip4_addr ip4;
}

const int ZTS_MAC_ADDRSTRLEN = 18;

const int ZTS_INET_ADDRSTRLEN = 16;

const int ZTS_INET6_ADDRSTRLEN = 46;

const int ZTS_IP_MAX_STR_LEN = 46;

const int ZTS_STORE_DATA_LEN = 4096;

const int ZTS_MAX_NETWORK_SHORT_NAME_LENGTH = 127;

const int ZTS_MAX_NETWORK_ROUTES = 32;

const int ZTS_MAX_ASSIGNED_ADDRESSES = 16;

const int ZTS_MAX_PEER_NETWORK_PATHS = 64;

const int ZTS_MAX_MULTICAST_SUBSCRIPTIONS = 1024;

const int ZTS_MAX_ENDPOINT_STR_LEN = 52;

const int ZTS_C_API_ONLY = 1;

const int __WORDSIZE = 64;

const int __DARWIN_ONLY_64_BIT_INO_T = 0;

const int __DARWIN_ONLY_UNIX_CONFORMANCE = 1;

const int __DARWIN_ONLY_VERS_1050 = 0;

const int __DARWIN_UNIX03 = 1;

const int __DARWIN_64_BIT_INO_T = 1;

const int __DARWIN_VERS_1050 = 1;

const int __DARWIN_NON_CANCELABLE = 0;

const String __DARWIN_SUF_64_BIT_INO_T = '\$INODE64';

const String __DARWIN_SUF_1050 = '\$1050';

const String __DARWIN_SUF_EXTSN = '\$DARWIN_EXTSN';

const int __DARWIN_C_ANSI = 4096;

const int __DARWIN_C_FULL = 900000;

const int __DARWIN_C_LEVEL = 900000;

const int __STDC_WANT_LIB_EXT1__ = 1;

const int __DARWIN_NO_LONG_LONG = 0;

const int _DARWIN_FEATURE_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = 1;

const int _DARWIN_FEATURE_UNIX_CONFORMANCE = 3;

const int __has_ptrcheck = 0;

const int __DARWIN_NULL = 0;

const int __PTHREAD_SIZE__ = 8176;

const int __PTHREAD_ATTR_SIZE__ = 56;

const int __PTHREAD_MUTEXATTR_SIZE__ = 8;

const int __PTHREAD_MUTEX_SIZE__ = 56;

const int __PTHREAD_CONDATTR_SIZE__ = 8;

const int __PTHREAD_COND_SIZE__ = 40;

const int __PTHREAD_ONCE_SIZE__ = 8;

const int __PTHREAD_RWLOCK_SIZE__ = 192;

const int __PTHREAD_RWLOCKATTR_SIZE__ = 16;

const int USER_ADDR_NULL = 0;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -32768;

const int INT_FAST32_MIN = -2147483648;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 32767;

const int INT_FAST32_MAX = 2147483647;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = 65535;

const int UINT_FAST32_MAX = 4294967295;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MAX = 9223372036854775807;

const int INTPTR_MIN = -9223372036854775808;

const int UINTPTR_MAX = -1;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIZE_MAX = -1;

const int RSIZE_MAX = 9223372036854775807;

const int WCHAR_MAX = 2147483647;

const int WCHAR_MIN = -2147483648;

const int WINT_MIN = -2147483648;

const int WINT_MAX = 2147483647;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int __DARWIN_WCHAR_MAX = 2147483647;

const int __DARWIN_WCHAR_MIN = -2147483648;

const int __DARWIN_WEOF = -1;

const int _FORTIFY_SOURCE = 2;

const int _POSIX_VERSION = 200112;

const int _POSIX2_VERSION = 200112;

const int _POSIX_VDISABLE = 255;

const int _POSIX_THREAD_KEYS_MAX = 128;

const int F_OK = 0;

const int X_OK = 1;

const int W_OK = 2;

const int R_OK = 4;

const int _READ_OK = 512;

const int _WRITE_OK = 1024;

const int _EXECUTE_OK = 2048;

const int _DELETE_OK = 4096;

const int _APPEND_OK = 8192;

const int _RMFILE_OK = 16384;

const int _RATTR_OK = 32768;

const int _WATTR_OK = 65536;

const int _REXT_OK = 131072;

const int _WEXT_OK = 262144;

const int _RPERM_OK = 524288;

const int _WPERM_OK = 1048576;

const int _CHOWN_OK = 2097152;

const int _ACCESS_EXTENDED_MASK = 4193792;

const int SEEK_SET = 0;

const int SEEK_CUR = 1;

const int SEEK_END = 2;

const int SEEK_HOLE = 3;

const int SEEK_DATA = 4;

const int L_SET = 0;

const int L_INCR = 1;

const int L_XTND = 2;

const int ACCESSX_MAX_DESCRIPTORS = 100;

const int ACCESSX_MAX_TABLESIZE = 16384;

const int _PC_LINK_MAX = 1;

const int _PC_MAX_CANON = 2;

const int _PC_MAX_INPUT = 3;

const int _PC_NAME_MAX = 4;

const int _PC_PATH_MAX = 5;

const int _PC_PIPE_BUF = 6;

const int _PC_CHOWN_RESTRICTED = 7;

const int _PC_NO_TRUNC = 8;

const int _PC_VDISABLE = 9;

const int _PC_NAME_CHARS_MAX = 10;

const int _PC_CASE_SENSITIVE = 11;

const int _PC_CASE_PRESERVING = 12;

const int _PC_EXTENDED_SECURITY_NP = 13;

const int _PC_AUTH_OPAQUE_NP = 14;

const int _PC_2_SYMLINKS = 15;

const int _PC_ALLOC_SIZE_MIN = 16;

const int _PC_ASYNC_IO = 17;

const int _PC_FILESIZEBITS = 18;

const int _PC_PRIO_IO = 19;

const int _PC_REC_INCR_XFER_SIZE = 20;

const int _PC_REC_MAX_XFER_SIZE = 21;

const int _PC_REC_MIN_XFER_SIZE = 22;

const int _PC_REC_XFER_ALIGN = 23;

const int _PC_SYMLINK_MAX = 24;

const int _PC_SYNC_IO = 25;

const int _PC_XATTR_SIZE_BITS = 26;

const int _PC_MIN_HOLE_SIZE = 27;

const int _CS_PATH = 1;

const int __API_TO_BE_DEPRECATED = 100000;

const int __API_TO_BE_DEPRECATED_MACOS = 100000;

const int __API_TO_BE_DEPRECATED_IOS = 100000;

const int __API_TO_BE_DEPRECATED_MACCATALYST = 100000;

const int __API_TO_BE_DEPRECATED_WATCHOS = 100000;

const int __API_TO_BE_DEPRECATED_TVOS = 100000;

const int __API_TO_BE_DEPRECATED_DRIVERKIT = 100000;

const int __API_TO_BE_DEPRECATED_XROS = 100000;

const int __MAC_10_0 = 1000;

const int __MAC_10_1 = 1010;

const int __MAC_10_2 = 1020;

const int __MAC_10_3 = 1030;

const int __MAC_10_4 = 1040;

const int __MAC_10_5 = 1050;

const int __MAC_10_6 = 1060;

const int __MAC_10_7 = 1070;

const int __MAC_10_8 = 1080;

const int __MAC_10_9 = 1090;

const int __MAC_10_10 = 101000;

const int __MAC_10_10_2 = 101002;

const int __MAC_10_10_3 = 101003;

const int __MAC_10_11 = 101100;

const int __MAC_10_11_2 = 101102;

const int __MAC_10_11_3 = 101103;

const int __MAC_10_11_4 = 101104;

const int __MAC_10_12 = 101200;

const int __MAC_10_12_1 = 101201;

const int __MAC_10_12_2 = 101202;

const int __MAC_10_12_4 = 101204;

const int __MAC_10_13 = 101300;

const int __MAC_10_13_1 = 101301;

const int __MAC_10_13_2 = 101302;

const int __MAC_10_13_4 = 101304;

const int __MAC_10_14 = 101400;

const int __MAC_10_14_1 = 101401;

const int __MAC_10_14_4 = 101404;

const int __MAC_10_14_5 = 101405;

const int __MAC_10_14_6 = 101406;

const int __MAC_10_15 = 101500;

const int __MAC_10_15_1 = 101501;

const int __MAC_10_15_4 = 101504;

const int __MAC_10_16 = 101600;

const int __MAC_11_0 = 110000;

const int __MAC_11_1 = 110100;

const int __MAC_11_3 = 110300;

const int __MAC_11_4 = 110400;

const int __MAC_11_5 = 110500;

const int __MAC_11_6 = 110600;

const int __MAC_12_0 = 120000;

const int __MAC_12_1 = 120100;

const int __MAC_12_2 = 120200;

const int __MAC_12_3 = 120300;

const int __MAC_12_4 = 120400;

const int __MAC_12_5 = 120500;

const int __MAC_13_0 = 130000;

const int __MAC_13_1 = 130100;

const int __MAC_13_2 = 130200;

const int __MAC_13_3 = 130300;

const int __MAC_13_4 = 130400;

const int __MAC_14_0 = 140000;

const int __IPHONE_2_0 = 20000;

const int __IPHONE_2_1 = 20100;

const int __IPHONE_2_2 = 20200;

const int __IPHONE_3_0 = 30000;

const int __IPHONE_3_1 = 30100;

const int __IPHONE_3_2 = 30200;

const int __IPHONE_4_0 = 40000;

const int __IPHONE_4_1 = 40100;

const int __IPHONE_4_2 = 40200;

const int __IPHONE_4_3 = 40300;

const int __IPHONE_5_0 = 50000;

const int __IPHONE_5_1 = 50100;

const int __IPHONE_6_0 = 60000;

const int __IPHONE_6_1 = 60100;

const int __IPHONE_7_0 = 70000;

const int __IPHONE_7_1 = 70100;

const int __IPHONE_8_0 = 80000;

const int __IPHONE_8_1 = 80100;

const int __IPHONE_8_2 = 80200;

const int __IPHONE_8_3 = 80300;

const int __IPHONE_8_4 = 80400;

const int __IPHONE_9_0 = 90000;

const int __IPHONE_9_1 = 90100;

const int __IPHONE_9_2 = 90200;

const int __IPHONE_9_3 = 90300;

const int __IPHONE_10_0 = 100000;

const int __IPHONE_10_1 = 100100;

const int __IPHONE_10_2 = 100200;

const int __IPHONE_10_3 = 100300;

const int __IPHONE_11_0 = 110000;

const int __IPHONE_11_1 = 110100;

const int __IPHONE_11_2 = 110200;

const int __IPHONE_11_3 = 110300;

const int __IPHONE_11_4 = 110400;

const int __IPHONE_12_0 = 120000;

const int __IPHONE_12_1 = 120100;

const int __IPHONE_12_2 = 120200;

const int __IPHONE_12_3 = 120300;

const int __IPHONE_12_4 = 120400;

const int __IPHONE_13_0 = 130000;

const int __IPHONE_13_1 = 130100;

const int __IPHONE_13_2 = 130200;

const int __IPHONE_13_3 = 130300;

const int __IPHONE_13_4 = 130400;

const int __IPHONE_13_5 = 130500;

const int __IPHONE_13_6 = 130600;

const int __IPHONE_13_7 = 130700;

const int __IPHONE_14_0 = 140000;

const int __IPHONE_14_1 = 140100;

const int __IPHONE_14_2 = 140200;

const int __IPHONE_14_3 = 140300;

const int __IPHONE_14_5 = 140500;

const int __IPHONE_14_4 = 140400;

const int __IPHONE_14_6 = 140600;

const int __IPHONE_14_7 = 140700;

const int __IPHONE_14_8 = 140800;

const int __IPHONE_15_0 = 150000;

const int __IPHONE_15_1 = 150100;

const int __IPHONE_15_2 = 150200;

const int __IPHONE_15_3 = 150300;

const int __IPHONE_15_4 = 150400;

const int __IPHONE_15_5 = 150500;

const int __IPHONE_15_6 = 150600;

const int __IPHONE_16_0 = 160000;

const int __IPHONE_16_1 = 160100;

const int __IPHONE_16_2 = 160200;

const int __IPHONE_16_3 = 160300;

const int __IPHONE_16_4 = 160400;

const int __IPHONE_16_5 = 160500;

const int __IPHONE_17_0 = 170000;

const int __WATCHOS_1_0 = 10000;

const int __WATCHOS_2_0 = 20000;

const int __WATCHOS_2_1 = 20100;

const int __WATCHOS_2_2 = 20200;

const int __WATCHOS_3_0 = 30000;

const int __WATCHOS_3_1 = 30100;

const int __WATCHOS_3_1_1 = 30101;

const int __WATCHOS_3_2 = 30200;

const int __WATCHOS_4_0 = 40000;

const int __WATCHOS_4_1 = 40100;

const int __WATCHOS_4_2 = 40200;

const int __WATCHOS_4_3 = 40300;

const int __WATCHOS_5_0 = 50000;

const int __WATCHOS_5_1 = 50100;

const int __WATCHOS_5_2 = 50200;

const int __WATCHOS_5_3 = 50300;

const int __WATCHOS_6_0 = 60000;

const int __WATCHOS_6_1 = 60100;

const int __WATCHOS_6_2 = 60200;

const int __WATCHOS_7_0 = 70000;

const int __WATCHOS_7_1 = 70100;

const int __WATCHOS_7_2 = 70200;

const int __WATCHOS_7_3 = 70300;

const int __WATCHOS_7_4 = 70400;

const int __WATCHOS_7_5 = 70500;

const int __WATCHOS_7_6 = 70600;

const int __WATCHOS_8_0 = 80000;

const int __WATCHOS_8_1 = 80100;

const int __WATCHOS_8_3 = 80300;

const int __WATCHOS_8_4 = 80400;

const int __WATCHOS_8_5 = 80500;

const int __WATCHOS_8_6 = 80600;

const int __WATCHOS_8_7 = 80700;

const int __WATCHOS_9_0 = 90000;

const int __WATCHOS_9_1 = 90100;

const int __WATCHOS_9_2 = 90200;

const int __WATCHOS_9_3 = 90300;

const int __WATCHOS_9_4 = 90400;

const int __WATCHOS_9_5 = 90500;

const int __WATCHOS_10_0 = 100000;

const int __TVOS_9_0 = 90000;

const int __TVOS_9_1 = 90100;

const int __TVOS_9_2 = 90200;

const int __TVOS_10_0 = 100000;

const int __TVOS_10_0_1 = 100001;

const int __TVOS_10_1 = 100100;

const int __TVOS_10_2 = 100200;

const int __TVOS_11_0 = 110000;

const int __TVOS_11_1 = 110100;

const int __TVOS_11_2 = 110200;

const int __TVOS_11_3 = 110300;

const int __TVOS_11_4 = 110400;

const int __TVOS_12_0 = 120000;

const int __TVOS_12_1 = 120100;

const int __TVOS_12_2 = 120200;

const int __TVOS_12_3 = 120300;

const int __TVOS_12_4 = 120400;

const int __TVOS_13_0 = 130000;

const int __TVOS_13_2 = 130200;

const int __TVOS_13_3 = 130300;

const int __TVOS_13_4 = 130400;

const int __TVOS_14_0 = 140000;

const int __TVOS_14_1 = 140100;

const int __TVOS_14_2 = 140200;

const int __TVOS_14_3 = 140300;

const int __TVOS_14_5 = 140500;

const int __TVOS_14_6 = 140600;

const int __TVOS_14_7 = 140700;

const int __TVOS_15_0 = 150000;

const int __TVOS_15_1 = 150100;

const int __TVOS_15_2 = 150200;

const int __TVOS_15_3 = 150300;

const int __TVOS_15_4 = 150400;

const int __TVOS_15_5 = 150500;

const int __TVOS_15_6 = 150600;

const int __TVOS_16_0 = 160000;

const int __TVOS_16_1 = 160100;

const int __TVOS_16_2 = 160200;

const int __TVOS_16_3 = 160300;

const int __TVOS_16_4 = 160400;

const int __TVOS_16_5 = 160500;

const int __TVOS_17_0 = 170000;

const int __BRIDGEOS_2_0 = 20000;

const int __BRIDGEOS_3_0 = 30000;

const int __BRIDGEOS_3_1 = 30100;

const int __BRIDGEOS_3_4 = 30400;

const int __BRIDGEOS_4_0 = 40000;

const int __BRIDGEOS_4_1 = 40100;

const int __BRIDGEOS_5_0 = 50000;

const int __BRIDGEOS_5_1 = 50100;

const int __BRIDGEOS_5_3 = 50300;

const int __BRIDGEOS_6_0 = 60000;

const int __BRIDGEOS_6_2 = 60200;

const int __BRIDGEOS_6_4 = 60400;

const int __BRIDGEOS_6_5 = 60500;

const int __BRIDGEOS_6_6 = 60600;

const int __BRIDGEOS_7_0 = 70000;

const int __BRIDGEOS_7_1 = 70100;

const int __BRIDGEOS_7_2 = 70200;

const int __BRIDGEOS_7_3 = 70300;

const int __BRIDGEOS_7_4 = 70400;

const int __BRIDGEOS_8_0 = 80000;

const int __DRIVERKIT_19_0 = 190000;

const int __DRIVERKIT_20_0 = 200000;

const int __DRIVERKIT_21_0 = 210000;

const int __DRIVERKIT_22_0 = 220000;

const int __DRIVERKIT_22_4 = 220400;

const int __DRIVERKIT_22_5 = 220500;

const int __DRIVERKIT_23_0 = 230000;

const int __XROS_1_0 = 10000;

const int MAC_OS_X_VERSION_10_0 = 1000;

const int MAC_OS_X_VERSION_10_1 = 1010;

const int MAC_OS_X_VERSION_10_2 = 1020;

const int MAC_OS_X_VERSION_10_3 = 1030;

const int MAC_OS_X_VERSION_10_4 = 1040;

const int MAC_OS_X_VERSION_10_5 = 1050;

const int MAC_OS_X_VERSION_10_6 = 1060;

const int MAC_OS_X_VERSION_10_7 = 1070;

const int MAC_OS_X_VERSION_10_8 = 1080;

const int MAC_OS_X_VERSION_10_9 = 1090;

const int MAC_OS_X_VERSION_10_10 = 101000;

const int MAC_OS_X_VERSION_10_10_2 = 101002;

const int MAC_OS_X_VERSION_10_10_3 = 101003;

const int MAC_OS_X_VERSION_10_11 = 101100;

const int MAC_OS_X_VERSION_10_11_2 = 101102;

const int MAC_OS_X_VERSION_10_11_3 = 101103;

const int MAC_OS_X_VERSION_10_11_4 = 101104;

const int MAC_OS_X_VERSION_10_12 = 101200;

const int MAC_OS_X_VERSION_10_12_1 = 101201;

const int MAC_OS_X_VERSION_10_12_2 = 101202;

const int MAC_OS_X_VERSION_10_12_4 = 101204;

const int MAC_OS_X_VERSION_10_13 = 101300;

const int MAC_OS_X_VERSION_10_13_1 = 101301;

const int MAC_OS_X_VERSION_10_13_2 = 101302;

const int MAC_OS_X_VERSION_10_13_4 = 101304;

const int MAC_OS_X_VERSION_10_14 = 101400;

const int MAC_OS_X_VERSION_10_14_1 = 101401;

const int MAC_OS_X_VERSION_10_14_4 = 101404;

const int MAC_OS_X_VERSION_10_14_5 = 101405;

const int MAC_OS_X_VERSION_10_14_6 = 101406;

const int MAC_OS_X_VERSION_10_15 = 101500;

const int MAC_OS_X_VERSION_10_15_1 = 101501;

const int MAC_OS_X_VERSION_10_15_4 = 101504;

const int MAC_OS_X_VERSION_10_16 = 101600;

const int MAC_OS_VERSION_11_0 = 110000;

const int MAC_OS_VERSION_11_1 = 110100;

const int MAC_OS_VERSION_11_3 = 110300;

const int MAC_OS_VERSION_11_4 = 110400;

const int MAC_OS_VERSION_11_5 = 110500;

const int MAC_OS_VERSION_11_6 = 110600;

const int MAC_OS_VERSION_12_0 = 120000;

const int MAC_OS_VERSION_12_1 = 120100;

const int MAC_OS_VERSION_12_2 = 120200;

const int MAC_OS_VERSION_12_3 = 120300;

const int MAC_OS_VERSION_12_4 = 120400;

const int MAC_OS_VERSION_12_5 = 120500;

const int MAC_OS_VERSION_13_0 = 130000;

const int MAC_OS_VERSION_13_1 = 130100;

const int MAC_OS_VERSION_13_2 = 130200;

const int MAC_OS_VERSION_13_3 = 130300;

const int MAC_OS_VERSION_13_4 = 130400;

const int MAC_OS_VERSION_14_0 = 140000;

const int __MAC_OS_X_VERSION_MIN_REQUIRED = 140000;

const int __MAC_OS_X_VERSION_MAX_ALLOWED = 140000;

const int __ENABLE_LEGACY_MAC_AVAILABILITY = 1;

const int NULL = 0;

const int STDIN_FILENO = 0;

const int STDOUT_FILENO = 1;

const int STDERR_FILENO = 2;

const int _XOPEN_VERSION = 600;

const int _XOPEN_XCU_VERSION = 4;

const int _POSIX_ADVISORY_INFO = -1;

const int _POSIX_ASYNCHRONOUS_IO = -1;

const int _POSIX_BARRIERS = -1;

const int _POSIX_CHOWN_RESTRICTED = 200112;

const int _POSIX_CLOCK_SELECTION = -1;

const int _POSIX_CPUTIME = -1;

const int _POSIX_FSYNC = 200112;

const int _POSIX_IPV6 = 200112;

const int _POSIX_JOB_CONTROL = 200112;

const int _POSIX_MAPPED_FILES = 200112;

const int _POSIX_MEMLOCK = -1;

const int _POSIX_MEMLOCK_RANGE = -1;

const int _POSIX_MEMORY_PROTECTION = 200112;

const int _POSIX_MESSAGE_PASSING = -1;

const int _POSIX_MONOTONIC_CLOCK = -1;

const int _POSIX_NO_TRUNC = 200112;

const int _POSIX_PRIORITIZED_IO = -1;

const int _POSIX_PRIORITY_SCHEDULING = -1;

const int _POSIX_RAW_SOCKETS = -1;

const int _POSIX_READER_WRITER_LOCKS = 200112;

const int _POSIX_REALTIME_SIGNALS = -1;

const int _POSIX_REGEXP = 200112;

const int _POSIX_SAVED_IDS = 200112;

const int _POSIX_SEMAPHORES = -1;

const int _POSIX_SHARED_MEMORY_OBJECTS = -1;

const int _POSIX_SHELL = 200112;

const int _POSIX_SPAWN = 200112;

const int _POSIX_SPIN_LOCKS = -1;

const int _POSIX_SPORADIC_SERVER = -1;

const int _POSIX_SYNCHRONIZED_IO = -1;

const int _POSIX_THREAD_ATTR_STACKADDR = 200112;

const int _POSIX_THREAD_ATTR_STACKSIZE = 200112;

const int _POSIX_THREAD_CPUTIME = -1;

const int _POSIX_THREAD_PRIO_INHERIT = -1;

const int _POSIX_THREAD_PRIO_PROTECT = -1;

const int _POSIX_THREAD_PRIORITY_SCHEDULING = -1;

const int _POSIX_THREAD_PROCESS_SHARED = 200112;

const int _POSIX_THREAD_SAFE_FUNCTIONS = 200112;

const int _POSIX_THREAD_SPORADIC_SERVER = -1;

const int _POSIX_THREADS = 200112;

const int _POSIX_TIMEOUTS = -1;

const int _POSIX_TIMERS = -1;

const int _POSIX_TRACE = -1;

const int _POSIX_TRACE_EVENT_FILTER = -1;

const int _POSIX_TRACE_INHERIT = -1;

const int _POSIX_TRACE_LOG = -1;

const int _POSIX_TYPED_MEMORY_OBJECTS = -1;

const int _POSIX2_C_BIND = 200112;

const int _POSIX2_C_DEV = 200112;

const int _POSIX2_CHAR_TERM = 200112;

const int _POSIX2_FORT_DEV = -1;

const int _POSIX2_FORT_RUN = 200112;

const int _POSIX2_LOCALEDEF = 200112;

const int _POSIX2_PBS = -1;

const int _POSIX2_PBS_ACCOUNTING = -1;

const int _POSIX2_PBS_CHECKPOINT = -1;

const int _POSIX2_PBS_LOCATE = -1;

const int _POSIX2_PBS_MESSAGE = -1;

const int _POSIX2_PBS_TRACK = -1;

const int _POSIX2_SW_DEV = 200112;

const int _POSIX2_UPE = 200112;

const int __ILP32_OFF32 = -1;

const int __ILP32_OFFBIG = -1;

const int __LP64_OFF64 = 1;

const int __LPBIG_OFFBIG = 1;

const int _POSIX_V6_ILP32_OFF32 = -1;

const int _POSIX_V6_ILP32_OFFBIG = -1;

const int _POSIX_V6_LP64_OFF64 = 1;

const int _POSIX_V6_LPBIG_OFFBIG = 1;

const int _POSIX_V7_ILP32_OFF32 = -1;

const int _POSIX_V7_ILP32_OFFBIG = -1;

const int _POSIX_V7_LP64_OFF64 = 1;

const int _POSIX_V7_LPBIG_OFFBIG = 1;

const int _V6_ILP32_OFF32 = -1;

const int _V6_ILP32_OFFBIG = -1;

const int _V6_LP64_OFF64 = 1;

const int _V6_LPBIG_OFFBIG = 1;

const int _XBS5_ILP32_OFF32 = -1;

const int _XBS5_ILP32_OFFBIG = -1;

const int _XBS5_LP64_OFF64 = 1;

const int _XBS5_LPBIG_OFFBIG = 1;

const int _XOPEN_CRYPT = 1;

const int _XOPEN_ENH_I18N = 1;

const int _XOPEN_LEGACY = -1;

const int _XOPEN_REALTIME = -1;

const int _XOPEN_REALTIME_THREADS = -1;

const int _XOPEN_SHM = 1;

const int _XOPEN_STREAMS = -1;

const int _XOPEN_UNIX = 1;

const int _SC_ARG_MAX = 1;

const int _SC_CHILD_MAX = 2;

const int _SC_CLK_TCK = 3;

const int _SC_NGROUPS_MAX = 4;

const int _SC_OPEN_MAX = 5;

const int _SC_JOB_CONTROL = 6;

const int _SC_SAVED_IDS = 7;

const int _SC_VERSION = 8;

const int _SC_BC_BASE_MAX = 9;

const int _SC_BC_DIM_MAX = 10;

const int _SC_BC_SCALE_MAX = 11;

const int _SC_BC_STRING_MAX = 12;

const int _SC_COLL_WEIGHTS_MAX = 13;

const int _SC_EXPR_NEST_MAX = 14;

const int _SC_LINE_MAX = 15;

const int _SC_RE_DUP_MAX = 16;

const int _SC_2_VERSION = 17;

const int _SC_2_C_BIND = 18;

const int _SC_2_C_DEV = 19;

const int _SC_2_CHAR_TERM = 20;

const int _SC_2_FORT_DEV = 21;

const int _SC_2_FORT_RUN = 22;

const int _SC_2_LOCALEDEF = 23;

const int _SC_2_SW_DEV = 24;

const int _SC_2_UPE = 25;

const int _SC_STREAM_MAX = 26;

const int _SC_TZNAME_MAX = 27;

const int _SC_ASYNCHRONOUS_IO = 28;

const int _SC_PAGESIZE = 29;

const int _SC_MEMLOCK = 30;

const int _SC_MEMLOCK_RANGE = 31;

const int _SC_MEMORY_PROTECTION = 32;

const int _SC_MESSAGE_PASSING = 33;

const int _SC_PRIORITIZED_IO = 34;

const int _SC_PRIORITY_SCHEDULING = 35;

const int _SC_REALTIME_SIGNALS = 36;

const int _SC_SEMAPHORES = 37;

const int _SC_FSYNC = 38;

const int _SC_SHARED_MEMORY_OBJECTS = 39;

const int _SC_SYNCHRONIZED_IO = 40;

const int _SC_TIMERS = 41;

const int _SC_AIO_LISTIO_MAX = 42;

const int _SC_AIO_MAX = 43;

const int _SC_AIO_PRIO_DELTA_MAX = 44;

const int _SC_DELAYTIMER_MAX = 45;

const int _SC_MQ_OPEN_MAX = 46;

const int _SC_MAPPED_FILES = 47;

const int _SC_RTSIG_MAX = 48;

const int _SC_SEM_NSEMS_MAX = 49;

const int _SC_SEM_VALUE_MAX = 50;

const int _SC_SIGQUEUE_MAX = 51;

const int _SC_TIMER_MAX = 52;

const int _SC_NPROCESSORS_CONF = 57;

const int _SC_NPROCESSORS_ONLN = 58;

const int _SC_2_PBS = 59;

const int _SC_2_PBS_ACCOUNTING = 60;

const int _SC_2_PBS_CHECKPOINT = 61;

const int _SC_2_PBS_LOCATE = 62;

const int _SC_2_PBS_MESSAGE = 63;

const int _SC_2_PBS_TRACK = 64;

const int _SC_ADVISORY_INFO = 65;

const int _SC_BARRIERS = 66;

const int _SC_CLOCK_SELECTION = 67;

const int _SC_CPUTIME = 68;

const int _SC_FILE_LOCKING = 69;

const int _SC_GETGR_R_SIZE_MAX = 70;

const int _SC_GETPW_R_SIZE_MAX = 71;

const int _SC_HOST_NAME_MAX = 72;

const int _SC_LOGIN_NAME_MAX = 73;

const int _SC_MONOTONIC_CLOCK = 74;

const int _SC_MQ_PRIO_MAX = 75;

const int _SC_READER_WRITER_LOCKS = 76;

const int _SC_REGEXP = 77;

const int _SC_SHELL = 78;

const int _SC_SPAWN = 79;

const int _SC_SPIN_LOCKS = 80;

const int _SC_SPORADIC_SERVER = 81;

const int _SC_THREAD_ATTR_STACKADDR = 82;

const int _SC_THREAD_ATTR_STACKSIZE = 83;

const int _SC_THREAD_CPUTIME = 84;

const int _SC_THREAD_DESTRUCTOR_ITERATIONS = 85;

const int _SC_THREAD_KEYS_MAX = 86;

const int _SC_THREAD_PRIO_INHERIT = 87;

const int _SC_THREAD_PRIO_PROTECT = 88;

const int _SC_THREAD_PRIORITY_SCHEDULING = 89;

const int _SC_THREAD_PROCESS_SHARED = 90;

const int _SC_THREAD_SAFE_FUNCTIONS = 91;

const int _SC_THREAD_SPORADIC_SERVER = 92;

const int _SC_THREAD_STACK_MIN = 93;

const int _SC_THREAD_THREADS_MAX = 94;

const int _SC_TIMEOUTS = 95;

const int _SC_THREADS = 96;

const int _SC_TRACE = 97;

const int _SC_TRACE_EVENT_FILTER = 98;

const int _SC_TRACE_INHERIT = 99;

const int _SC_TRACE_LOG = 100;

const int _SC_TTY_NAME_MAX = 101;

const int _SC_TYPED_MEMORY_OBJECTS = 102;

const int _SC_V6_ILP32_OFF32 = 103;

const int _SC_V6_ILP32_OFFBIG = 104;

const int _SC_V6_LP64_OFF64 = 105;

const int _SC_V6_LPBIG_OFFBIG = 106;

const int _SC_IPV6 = 118;

const int _SC_RAW_SOCKETS = 119;

const int _SC_SYMLOOP_MAX = 120;

const int _SC_ATEXIT_MAX = 107;

const int _SC_IOV_MAX = 56;

const int _SC_PAGE_SIZE = 29;

const int _SC_XOPEN_CRYPT = 108;

const int _SC_XOPEN_ENH_I18N = 109;

const int _SC_XOPEN_LEGACY = 110;

const int _SC_XOPEN_REALTIME = 111;

const int _SC_XOPEN_REALTIME_THREADS = 112;

const int _SC_XOPEN_SHM = 113;

const int _SC_XOPEN_STREAMS = 114;

const int _SC_XOPEN_UNIX = 115;

const int _SC_XOPEN_VERSION = 116;

const int _SC_XOPEN_XCU_VERSION = 121;

const int _SC_XBS5_ILP32_OFF32 = 122;

const int _SC_XBS5_ILP32_OFFBIG = 123;

const int _SC_XBS5_LP64_OFF64 = 124;

const int _SC_XBS5_LPBIG_OFFBIG = 125;

const int _SC_SS_REPL_MAX = 126;

const int _SC_TRACE_EVENT_NAME_MAX = 127;

const int _SC_TRACE_NAME_MAX = 128;

const int _SC_TRACE_SYS_MAX = 129;

const int _SC_TRACE_USER_EVENT_MAX = 130;

const int _SC_PASS_MAX = 131;

const int _SC_PHYS_PAGES = 200;

const int _CS_POSIX_V6_ILP32_OFF32_CFLAGS = 2;

const int _CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 3;

const int _CS_POSIX_V6_ILP32_OFF32_LIBS = 4;

const int _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 5;

const int _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 6;

const int _CS_POSIX_V6_ILP32_OFFBIG_LIBS = 7;

const int _CS_POSIX_V6_LP64_OFF64_CFLAGS = 8;

const int _CS_POSIX_V6_LP64_OFF64_LDFLAGS = 9;

const int _CS_POSIX_V6_LP64_OFF64_LIBS = 10;

const int _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 11;

const int _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 12;

const int _CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 13;

const int _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS = 14;

const int _CS_XBS5_ILP32_OFF32_CFLAGS = 20;

const int _CS_XBS5_ILP32_OFF32_LDFLAGS = 21;

const int _CS_XBS5_ILP32_OFF32_LIBS = 22;

const int _CS_XBS5_ILP32_OFF32_LINTFLAGS = 23;

const int _CS_XBS5_ILP32_OFFBIG_CFLAGS = 24;

const int _CS_XBS5_ILP32_OFFBIG_LDFLAGS = 25;

const int _CS_XBS5_ILP32_OFFBIG_LIBS = 26;

const int _CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 27;

const int _CS_XBS5_LP64_OFF64_CFLAGS = 28;

const int _CS_XBS5_LP64_OFF64_LDFLAGS = 29;

const int _CS_XBS5_LP64_OFF64_LIBS = 30;

const int _CS_XBS5_LP64_OFF64_LINTFLAGS = 31;

const int _CS_XBS5_LPBIG_OFFBIG_CFLAGS = 32;

const int _CS_XBS5_LPBIG_OFFBIG_LDFLAGS = 33;

const int _CS_XBS5_LPBIG_OFFBIG_LIBS = 34;

const int _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 35;

const int _CS_DARWIN_USER_DIR = 65536;

const int _CS_DARWIN_USER_TEMP_DIR = 65537;

const int _CS_DARWIN_USER_CACHE_DIR = 65538;

const int F_ULOCK = 0;

const int F_LOCK = 1;

const int F_TLOCK = 2;

const int F_TEST = 3;

const int __DARWIN_FD_SETSIZE = 1024;

const int __DARWIN_NBBY = 8;

const int __DARWIN_NFDBITS = 32;

const int FD_SETSIZE = 1024;

const int SYNC_VOLUME_FULLSYNC = 1;

const int SYNC_VOLUME_WAIT = 2;

const int ZTS_IPADDR_NONE = 4294967295;

const int ZTS_IPADDR_LOOPBACK = 2130706433;

const int ZTS_IPADDR_ANY = 0;

const int ZTS_IPADDR_BROADCAST = 4294967295;

const int ZTS_INADDR_NONE = 4294967295;

const int ZTS_INADDR_LOOPBACK = 2130706433;

const int ZTS_INADDR_ANY = 0;

const int ZTS_INADDR_BROADCAST = 4294967295;

const int ZTS_SOCK_STREAM = 1;

const int ZTS_SOCK_DGRAM = 2;

const int ZTS_SOCK_RAW = 3;

const int ZTS_AF_UNSPEC = 0;

const int ZTS_AF_INET = 2;

const int ZTS_AF_INET6 = 10;

const int ZTS_PF_INET = 2;

const int ZTS_PF_INET6 = 10;

const int ZTS_PF_UNSPEC = 0;

const int ZTS_IPPROTO_IP = 0;

const int ZTS_IPPROTO_ICMP = 1;

const int ZTS_IPPROTO_TCP = 6;

const int ZTS_IPPROTO_UDP = 17;

const int ZTS_IPPROTO_IPV6 = 41;

const int ZTS_IPPROTO_ICMPV6 = 58;

const int ZTS_IPPROTO_UDPLITE = 136;

const int ZTS_IPPROTO_RAW = 255;

const int ZTS_MSG_PEEK = 1;

const int ZTS_MSG_WAITALL = 2;

const int ZTS_MSG_OOB = 4;

const int ZTS_MSG_DONTWAIT = 8;

const int ZTS_MSG_MORE = 16;

const int ZTS_IOCPARM_MASK = 127;

const int ZTS_IOC_VOID = 536870912;

const int ZTS_IOC_OUT = 1073741824;

const int ZTS_IOC_IN = 2147483648;

const int ZTS_IOC_INOUT = 3221225472;

const int ZTS_FIONREAD = 1074292351;

const int ZTS_FIONBIO = 2148034174;

const int SIN_ZERO_LEN = 8;

const int ZTS_MAX_NUM_ROOTS = 16;

const int ZTS_MAX_ENDPOINTS_PER_ROOT = 32;

const int ZTS_DISABLE_CENTRAL_API = 1;

const int ZTS_ID_STR_BUF_LEN = 384;

const int ZTS_SOL_SOCKET = 4095;

const int ZTS_SO_DEBUG = 1;

const int ZTS_SO_ACCEPTCONN = 2;

const int ZTS_SO_REUSEADDR = 4;

const int ZTS_SO_KEEPALIVE = 8;

const int ZTS_SO_DONTROUTE = 16;

const int ZTS_SO_BROADCAST = 32;

const int ZTS_SO_USELOOPBACK = 64;

const int ZTS_SO_LINGER = 128;

const int ZTS_SO_DONTLINGER = -129;

const int ZTS_SO_OOBINLINE = 256;

const int ZTS_SO_REUSEPORT = 512;

const int ZTS_SO_SNDBUF = 4097;

const int ZTS_SO_RCVBUF = 4098;

const int ZTS_SO_SNDLOWAT = 4099;

const int ZTS_SO_RCVLOWAT = 4100;

const int ZTS_SO_SNDTIMEO = 4101;

const int ZTS_SO_RCVTIMEO = 4102;

const int ZTS_SO_ERROR = 4103;

const int ZTS_SO_TYPE = 4104;

const int ZTS_SO_CONTIMEO = 4105;

const int ZTS_SO_NO_CHECK = 4106;

const int ZTS_SO_BINDTODEVICE = 4107;

const int ZTS_IP_TOS = 1;

const int ZTS_IP_TTL = 2;

const int ZTS_IP_PKTINFO = 8;

const int ZTS_TCP_NODELAY = 1;

const int ZTS_TCP_KEEPALIVE = 2;

const int ZTS_TCP_KEEPIDLE = 3;

const int ZTS_TCP_KEEPINTVL = 4;

const int ZTS_TCP_KEEPCNT = 5;

const int ZTS_IPV6_CHECKSUM = 7;

const int ZTS_IPV6_V6ONLY = 27;

const int ZTS_UDPLITE_SEND_CSCOV = 1;

const int ZTS_UDPLITE_RECV_CSCOV = 2;

const int ZTS_IP_MULTICAST_TTL = 5;

const int ZTS_IP_MULTICAST_IF = 6;

const int ZTS_IP_MULTICAST_LOOP = 7;

const int ZTS_IP_ADD_MEMBERSHIP = 3;

const int ZTS_IP_DROP_MEMBERSHIP = 4;

const int ZTS_IPV6_JOIN_GROUP = 12;

const int ZTS_IPV6_ADD_MEMBERSHIP = 12;

const int ZTS_IPV6_LEAVE_GROUP = 13;

const int ZTS_IPV6_DROP_MEMBERSHIP = 13;

const int ZTS_IPTOS_TOS_MASK = 30;

const int ZTS_IPTOS_LOWDELAY = 16;

const int ZTS_IPTOS_THROUGHPUT = 8;

const int ZTS_IPTOS_RELIABILITY = 4;

const int ZTS_IPTOS_LOWCOST = 2;

const int ZTS_IPTOS_MINCOST = 2;

const int ZTS_IPTOS_PREC_MASK = 224;

const int ZTS_IPTOS_PREC_NETCONTROL = 224;

const int ZTS_IPTOS_PREC_INTERNETCONTROL = 192;

const int ZTS_IPTOS_PREC_CRITIC_ECP = 160;

const int ZTS_IPTOS_PREC_FLASHOVERRIDE = 128;

const int ZTS_IPTOS_PREC_FLASH = 96;

const int ZTS_IPTOS_PREC_IMMEDIATE = 64;

const int ZTS_IPTOS_PREC_PRIORITY = 32;

const int ZTS_IPTOS_PREC_ROUTINE = 0;

const int LWIP_SOCKET_OFFSET = 0;

const int MEMP_NUM_NETCONN = 1024;

const int ZTS_FD_SETSIZE = 1024;

const int ZTS_F_GETFL = 3;

const int ZTS_F_SETFL = 4;

const int ZTS_O_NONBLOCK = 1;

const int ZTS_O_NDELAY = 1;

const int ZTS_O_RDONLY = 2;

const int ZTS_O_WRONLY = 4;

const int ZTS_O_RDWR = 6;

const int ZTS_POLLIN = 1;

const int ZTS_POLLOUT = 2;

const int ZTS_POLLERR = 4;

const int ZTS_POLLNVAL = 8;

const int ZTS_POLLRDNORM = 16;

const int ZTS_POLLRDBAND = 32;

const int ZTS_POLLPRI = 64;

const int ZTS_POLLWRNORM = 128;

const int ZTS_POLLWRBAND = 256;

const int ZTS_POLLHUP = 512;

const int ZTS_MSG_TRUNC = 4;

const int ZTS_MSG_CTRUNC = 8;

const int ZTS_SHUT_RD = 0;

const int ZTS_SHUT_WR = 1;

const int ZTS_SHUT_RDWR = 2;
